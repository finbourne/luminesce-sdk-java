/*
 * FINBOURNE Luminesce Web API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.luminesce.api;

import com.finbourne.luminesce.ApiCallback;
import com.finbourne.luminesce.ApiClient;
import com.finbourne.luminesce.ApiException;
import com.finbourne.luminesce.ApiResponse;
import com.finbourne.luminesce.Configuration;
import com.finbourne.luminesce.Pair;
import com.finbourne.luminesce.ProgressRequestBody;
import com.finbourne.luminesce.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.finbourne.luminesce.model.ConvertToViewData;
import com.finbourne.luminesce.model.ErrorHighlightRequest;
import com.finbourne.luminesce.model.ErrorHighlightResponse;
import com.finbourne.luminesce.model.FileReaderBuilderDef;
import com.finbourne.luminesce.model.FileReaderBuilderResponse;
import com.finbourne.luminesce.model.IntellisenseRequest;
import com.finbourne.luminesce.model.IntellisenseResponse;
import com.finbourne.luminesce.model.LusidProblemDetails;
import com.finbourne.luminesce.model.QueryDesign;
import com.finbourne.luminesce.model.WriterDesign;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SqlDesignApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SqlDesignApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SqlDesignApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call putFileReadDesignToSqlCall(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fileReaderBuilderDef;

        // create path and map variables
        String localVarPath = "/api/Sql/fromfilereaddesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (executeQuery != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("executeQuery", executeQuery));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putFileReadDesignToSqlValidateBeforeCall(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileReaderBuilderDef' is set
        if (fileReaderBuilderDef == null) {
            throw new ApiException("Missing the required parameter 'fileReaderBuilderDef' when calling putFileReadDesignToSql(Async)");
        }

        return putFileReadDesignToSqlCall(fileReaderBuilderDef, executeQuery, _callback);

    }


    private ApiResponse<FileReaderBuilderResponse> putFileReadDesignToSqlWithHttpInfo(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery) throws ApiException {
        okhttp3.Call localVarCall = putFileReadDesignToSqlValidateBeforeCall(fileReaderBuilderDef, executeQuery, null);
        Type localVarReturnType = new TypeToken<FileReaderBuilderResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putFileReadDesignToSqlAsync(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery, final ApiCallback<FileReaderBuilderResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = putFileReadDesignToSqlValidateBeforeCall(fileReaderBuilderDef, executeQuery, _callback);
        Type localVarReturnType = new TypeToken<FileReaderBuilderResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputFileReadDesignToSqlRequest {
        private final FileReaderBuilderDef fileReaderBuilderDef;
        private Boolean executeQuery;

        private APIputFileReadDesignToSqlRequest(FileReaderBuilderDef fileReaderBuilderDef) {
            this.fileReaderBuilderDef = fileReaderBuilderDef;
        }

        /**
         * Set executeQuery
         * @param executeQuery Should the generated query be executed to build preview data or determine errors.&gt; (optional, default to true)
         * @return APIputFileReadDesignToSqlRequest
         */
        public APIputFileReadDesignToSqlRequest executeQuery(Boolean executeQuery) {
            this.executeQuery = executeQuery;
            return this;
        }

        /**
         * Build call for putFileReadDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putFileReadDesignToSqlCall(fileReaderBuilderDef, executeQuery, _callback);
        }

        /**
         * Execute putFileReadDesignToSql request
         * @return FileReaderBuilderResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public FileReaderBuilderResponse execute() throws ApiException {
            ApiResponse<FileReaderBuilderResponse> localVarResp = putFileReadDesignToSqlWithHttpInfo(fileReaderBuilderDef, executeQuery);
            return localVarResp.getData();
        }

        /**
         * Execute putFileReadDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;FileReaderBuilderResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<FileReaderBuilderResponse> executeWithHttpInfo() throws ApiException {
            return putFileReadDesignToSqlWithHttpInfo(fileReaderBuilderDef, executeQuery);
        }

        /**
         * Execute putFileReadDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<FileReaderBuilderResponse> _callback) throws ApiException {
            return putFileReadDesignToSqlAsync(fileReaderBuilderDef, executeQuery, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutFileReadDesignToSql: Generates file read SQL from a structured query design
     * SQL Designer specification to generate SQL from
     * @param fileReaderBuilderDef Structured file read design object to generate SQL from (required)
     * @return APIputFileReadDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputFileReadDesignToSqlRequest putFileReadDesignToSql(FileReaderBuilderDef fileReaderBuilderDef) {
        return new APIputFileReadDesignToSqlRequest(fileReaderBuilderDef);
    }
    private okhttp3.Call putIntellisenseCall(IntellisenseRequest intellisenseRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = intellisenseRequest;

        // create path and map variables
        String localVarPath = "/api/Sql/intellisense";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putIntellisenseValidateBeforeCall(IntellisenseRequest intellisenseRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'intellisenseRequest' is set
        if (intellisenseRequest == null) {
            throw new ApiException("Missing the required parameter 'intellisenseRequest' when calling putIntellisense(Async)");
        }

        return putIntellisenseCall(intellisenseRequest, _callback);

    }


    private ApiResponse<IntellisenseResponse> putIntellisenseWithHttpInfo(IntellisenseRequest intellisenseRequest) throws ApiException {
        okhttp3.Call localVarCall = putIntellisenseValidateBeforeCall(intellisenseRequest, null);
        Type localVarReturnType = new TypeToken<IntellisenseResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putIntellisenseAsync(IntellisenseRequest intellisenseRequest, final ApiCallback<IntellisenseResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = putIntellisenseValidateBeforeCall(intellisenseRequest, _callback);
        Type localVarReturnType = new TypeToken<IntellisenseResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputIntellisenseRequest {
        private final IntellisenseRequest intellisenseRequest;

        private APIputIntellisenseRequest(IntellisenseRequest intellisenseRequest) {
            this.intellisenseRequest = intellisenseRequest;
        }

        /**
         * Build call for putIntellisense
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putIntellisenseCall(intellisenseRequest, _callback);
        }

        /**
         * Execute putIntellisense request
         * @return IntellisenseResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public IntellisenseResponse execute() throws ApiException {
            ApiResponse<IntellisenseResponse> localVarResp = putIntellisenseWithHttpInfo(intellisenseRequest);
            return localVarResp.getData();
        }

        /**
         * Execute putIntellisense request with HTTP info returned
         * @return ApiResponse&lt;IntellisenseResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IntellisenseResponse> executeWithHttpInfo() throws ApiException {
            return putIntellisenseWithHttpInfo(intellisenseRequest);
        }

        /**
         * Execute putIntellisense request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IntellisenseResponse> _callback) throws ApiException {
            return putIntellisenseAsync(intellisenseRequest, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutIntellisense: Generate a set of possible intellisense prompts given a SQL snip-it (in need not yet be valid) and cursor location
     * SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.
     * @param intellisenseRequest  (required)
     * @return APIputIntellisenseRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputIntellisenseRequest putIntellisense(IntellisenseRequest intellisenseRequest) {
        return new APIputIntellisenseRequest(intellisenseRequest);
    }
    private okhttp3.Call putIntellisenseErrorCall(ErrorHighlightRequest errorHighlightRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = errorHighlightRequest;

        // create path and map variables
        String localVarPath = "/api/Sql/intellisenseError";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putIntellisenseErrorValidateBeforeCall(ErrorHighlightRequest errorHighlightRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'errorHighlightRequest' is set
        if (errorHighlightRequest == null) {
            throw new ApiException("Missing the required parameter 'errorHighlightRequest' when calling putIntellisenseError(Async)");
        }

        return putIntellisenseErrorCall(errorHighlightRequest, _callback);

    }


    private ApiResponse<ErrorHighlightResponse> putIntellisenseErrorWithHttpInfo(ErrorHighlightRequest errorHighlightRequest) throws ApiException {
        okhttp3.Call localVarCall = putIntellisenseErrorValidateBeforeCall(errorHighlightRequest, null);
        Type localVarReturnType = new TypeToken<ErrorHighlightResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putIntellisenseErrorAsync(ErrorHighlightRequest errorHighlightRequest, final ApiCallback<ErrorHighlightResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = putIntellisenseErrorValidateBeforeCall(errorHighlightRequest, _callback);
        Type localVarReturnType = new TypeToken<ErrorHighlightResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputIntellisenseErrorRequest {
        private final ErrorHighlightRequest errorHighlightRequest;

        private APIputIntellisenseErrorRequest(ErrorHighlightRequest errorHighlightRequest) {
            this.errorHighlightRequest = errorHighlightRequest;
        }

        /**
         * Build call for putIntellisenseError
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putIntellisenseErrorCall(errorHighlightRequest, _callback);
        }

        /**
         * Execute putIntellisenseError request
         * @return ErrorHighlightResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ErrorHighlightResponse execute() throws ApiException {
            ApiResponse<ErrorHighlightResponse> localVarResp = putIntellisenseErrorWithHttpInfo(errorHighlightRequest);
            return localVarResp.getData();
        }

        /**
         * Execute putIntellisenseError request with HTTP info returned
         * @return ApiResponse&lt;ErrorHighlightResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ErrorHighlightResponse> executeWithHttpInfo() throws ApiException {
            return putIntellisenseErrorWithHttpInfo(errorHighlightRequest);
        }

        /**
         * Execute putIntellisenseError request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ErrorHighlightResponse> _callback) throws ApiException {
            return putIntellisenseErrorAsync(errorHighlightRequest, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutIntellisenseError: Generate a set of error ranges, if any, in the given SQL (expressed as Lines)
     * SQL (by line) to syntax check and return error ranges from within, if any.
     * @param errorHighlightRequest  (required)
     * @return APIputIntellisenseErrorRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputIntellisenseErrorRequest putIntellisenseError(ErrorHighlightRequest errorHighlightRequest) {
        return new APIputIntellisenseErrorRequest(errorHighlightRequest);
    }
    private okhttp3.Call putQueryDesignToSqlCall(QueryDesign queryDesign, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = queryDesign;

        // create path and map variables
        String localVarPath = "/api/Sql/fromdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putQueryDesignToSqlValidateBeforeCall(QueryDesign queryDesign, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'queryDesign' is set
        if (queryDesign == null) {
            throw new ApiException("Missing the required parameter 'queryDesign' when calling putQueryDesignToSql(Async)");
        }

        return putQueryDesignToSqlCall(queryDesign, _callback);

    }


    private ApiResponse<String> putQueryDesignToSqlWithHttpInfo(QueryDesign queryDesign) throws ApiException {
        okhttp3.Call localVarCall = putQueryDesignToSqlValidateBeforeCall(queryDesign, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putQueryDesignToSqlAsync(QueryDesign queryDesign, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putQueryDesignToSqlValidateBeforeCall(queryDesign, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputQueryDesignToSqlRequest {
        private final QueryDesign queryDesign;

        private APIputQueryDesignToSqlRequest(QueryDesign queryDesign) {
            this.queryDesign = queryDesign;
        }

        /**
         * Build call for putQueryDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putQueryDesignToSqlCall(queryDesign, _callback);
        }

        /**
         * Execute putQueryDesignToSql request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putQueryDesignToSqlWithHttpInfo(queryDesign);
            return localVarResp.getData();
        }

        /**
         * Execute putQueryDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putQueryDesignToSqlWithHttpInfo(queryDesign);
        }

        /**
         * Execute putQueryDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putQueryDesignToSqlAsync(queryDesign, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutQueryDesignToSql: Generates SQL from a structured query design
     * SQL Designer specification to generate SQL from
     * @param queryDesign Structured Query design object to generate SQL from (required)
     * @return APIputQueryDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputQueryDesignToSqlRequest putQueryDesignToSql(QueryDesign queryDesign) {
        return new APIputQueryDesignToSqlRequest(queryDesign);
    }
    private okhttp3.Call putQueryToFormatCall(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/pretty";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trailingCommas != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trailingCommas", trailingCommas));
        }

        if (uppercaseKeywords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("uppercaseKeywords", uppercaseKeywords));
        }

        if (breakJoinOnSections != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakJoinOnSections", breakJoinOnSections));
        }

        if (spaceAfterExpandedComma != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("spaceAfterExpandedComma", spaceAfterExpandedComma));
        }

        if (keywordStandardization != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keywordStandardization", keywordStandardization));
        }

        if (expandCommaLists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandCommaLists", expandCommaLists));
        }

        if (expandInLists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandInLists", expandInLists));
        }

        if (expandBooleanExpressions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandBooleanExpressions", expandBooleanExpressions));
        }

        if (expandBetweenConditions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandBetweenConditions", expandBetweenConditions));
        }

        if (expandCaseStatements != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandCaseStatements", expandCaseStatements));
        }

        if (maxLineWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxLineWidth", maxLineWidth));
        }

        if (spaceBeforeTrailingSingleLineComments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("spaceBeforeTrailingSingleLineComments", spaceBeforeTrailingSingleLineComments));
        }

        if (multilineCommentExtraLineBreak != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("multilineCommentExtraLineBreak", multilineCommentExtraLineBreak));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putQueryToFormatValidateBeforeCall(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putQueryToFormat(Async)");
        }

        return putQueryToFormatCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);

    }


    private ApiResponse<String> putQueryToFormatWithHttpInfo(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak) throws ApiException {
        okhttp3.Call localVarCall = putQueryToFormatValidateBeforeCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putQueryToFormatAsync(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putQueryToFormatValidateBeforeCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputQueryToFormatRequest {
        private final String body;
        private Boolean trailingCommas;
        private Boolean uppercaseKeywords;
        private Boolean breakJoinOnSections;
        private Boolean spaceAfterExpandedComma;
        private Boolean keywordStandardization;
        private Boolean expandCommaLists;
        private Boolean expandInLists;
        private Boolean expandBooleanExpressions;
        private Boolean expandBetweenConditions;
        private Boolean expandCaseStatements;
        private Integer maxLineWidth;
        private Boolean spaceBeforeTrailingSingleLineComments;
        private Boolean multilineCommentExtraLineBreak;

        private APIputQueryToFormatRequest(String body) {
            this.body = body;
        }

        /**
         * Set trailingCommas
         * @param trailingCommas Should commas be after an expression (as opposed to before) (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest trailingCommas(Boolean trailingCommas) {
            this.trailingCommas = trailingCommas;
            return this;
        }

        /**
         * Set uppercaseKeywords
         * @param uppercaseKeywords Should key words be capitalized (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest uppercaseKeywords(Boolean uppercaseKeywords) {
            this.uppercaseKeywords = uppercaseKeywords;
            return this;
        }

        /**
         * Set breakJoinOnSections
         * @param breakJoinOnSections Should clauses on joins be given line breaks? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest breakJoinOnSections(Boolean breakJoinOnSections) {
            this.breakJoinOnSections = breakJoinOnSections;
            return this;
        }

        /**
         * Set spaceAfterExpandedComma
         * @param spaceAfterExpandedComma Should comma-lists have spaces after the commas? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest spaceAfterExpandedComma(Boolean spaceAfterExpandedComma) {
            this.spaceAfterExpandedComma = spaceAfterExpandedComma;
            return this;
        }

        /**
         * Set keywordStandardization
         * @param keywordStandardization Should the \&quot;nicest\&quot; key words be used? (e.g. JOIN -&gt; INNER JOIN) (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest keywordStandardization(Boolean keywordStandardization) {
            this.keywordStandardization = keywordStandardization;
            return this;
        }

        /**
         * Set expandCommaLists
         * @param expandCommaLists Should comma-lists (e.g. select a,b,c) have line breaks added? (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandCommaLists(Boolean expandCommaLists) {
            this.expandCommaLists = expandCommaLists;
            return this;
        }

        /**
         * Set expandInLists
         * @param expandInLists Should IN-lists have line breaks added? (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandInLists(Boolean expandInLists) {
            this.expandInLists = expandInLists;
            return this;
        }

        /**
         * Set expandBooleanExpressions
         * @param expandBooleanExpressions Should boolean expressions have line breaks added? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandBooleanExpressions(Boolean expandBooleanExpressions) {
            this.expandBooleanExpressions = expandBooleanExpressions;
            return this;
        }

        /**
         * Set expandBetweenConditions
         * @param expandBetweenConditions Should between conditions have line breaks added? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandBetweenConditions(Boolean expandBetweenConditions) {
            this.expandBetweenConditions = expandBetweenConditions;
            return this;
        }

        /**
         * Set expandCaseStatements
         * @param expandCaseStatements Should case-statements have line breaks added? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandCaseStatements(Boolean expandCaseStatements) {
            this.expandCaseStatements = expandCaseStatements;
            return this;
        }

        /**
         * Set maxLineWidth
         * @param maxLineWidth Maximum number of characters to allow on one line (if possible) (optional, default to 120)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest maxLineWidth(Integer maxLineWidth) {
            this.maxLineWidth = maxLineWidth;
            return this;
        }

        /**
         * Set spaceBeforeTrailingSingleLineComments
         * @param spaceBeforeTrailingSingleLineComments Should the be a space before trailing single line comments? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest spaceBeforeTrailingSingleLineComments(Boolean spaceBeforeTrailingSingleLineComments) {
            this.spaceBeforeTrailingSingleLineComments = spaceBeforeTrailingSingleLineComments;
            return this;
        }

        /**
         * Set multilineCommentExtraLineBreak
         * @param multilineCommentExtraLineBreak Should an additional line break be added after multi-line comments? (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest multilineCommentExtraLineBreak(Boolean multilineCommentExtraLineBreak) {
            this.multilineCommentExtraLineBreak = multilineCommentExtraLineBreak;
            return this;
        }

        /**
         * Build call for putQueryToFormat
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putQueryToFormatCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);
        }

        /**
         * Execute putQueryToFormat request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putQueryToFormatWithHttpInfo(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak);
            return localVarResp.getData();
        }

        /**
         * Execute putQueryToFormat request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putQueryToFormatWithHttpInfo(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak);
        }

        /**
         * Execute putQueryToFormat request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putQueryToFormatAsync(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);
        }
    }

    /**
     * PutQueryToFormat: Formats SQL into a more readable form, a.k.a. Pretty-Print the SQL.
     *  This formats SQL (given a set of options as to how to do so). It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. &#x60;&#x60;&#x60;sql select x,y,z from a inner join b on a.x&#x3D;b.x where x&gt;y or y!&#x3D;z &#x60;&#x60;&#x60; becomes &#x60;&#x60;&#x60;sql select x, y, z from a inner join b  on a.x &#x3D; b.x where x &gt; y  or y !&#x3D; z &#x60;&#x60;&#x60; 
     * @param body LuminesceSql to Pretty-Print. Even if it doesn&#39;t parse an attempt will be made to format it (required)
     * @return APIputQueryToFormatRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputQueryToFormatRequest putQueryToFormat(String body) {
        return new APIputQueryToFormatRequest(body);
    }
    private okhttp3.Call putSqlToFileReadDesignCall(Boolean determineAvailableSources, String body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/tofilereaddesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (determineAvailableSources != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("determineAvailableSources", determineAvailableSources));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToFileReadDesignValidateBeforeCall(Boolean determineAvailableSources, String body, final ApiCallback _callback) throws ApiException {
        return putSqlToFileReadDesignCall(determineAvailableSources, body, _callback);

    }


    private ApiResponse<FileReaderBuilderDef> putSqlToFileReadDesignWithHttpInfo(Boolean determineAvailableSources, String body) throws ApiException {
        okhttp3.Call localVarCall = putSqlToFileReadDesignValidateBeforeCall(determineAvailableSources, body, null);
        Type localVarReturnType = new TypeToken<FileReaderBuilderDef>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToFileReadDesignAsync(Boolean determineAvailableSources, String body, final ApiCallback<FileReaderBuilderDef> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToFileReadDesignValidateBeforeCall(determineAvailableSources, body, _callback);
        Type localVarReturnType = new TypeToken<FileReaderBuilderDef>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToFileReadDesignRequest {
        private Boolean determineAvailableSources;
        private String body;

        private APIputSqlToFileReadDesignRequest() {
        }

        /**
         * Set determineAvailableSources
         * @param determineAvailableSources Should the available sources be determined from &#x60;Sys.Registration&#x60; (optional, default to true)
         * @return APIputSqlToFileReadDesignRequest
         */
        public APIputSqlToFileReadDesignRequest determineAvailableSources(Boolean determineAvailableSources) {
            this.determineAvailableSources = determineAvailableSources;
            return this;
        }

        /**
         * Set body
         * @param body SQL query to generate the file read design object from (optional)
         * @return APIputSqlToFileReadDesignRequest
         */
        public APIputSqlToFileReadDesignRequest body(String body) {
            this.body = body;
            return this;
        }

        /**
         * Build call for putSqlToFileReadDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToFileReadDesignCall(determineAvailableSources, body, _callback);
        }

        /**
         * Execute putSqlToFileReadDesign request
         * @return FileReaderBuilderDef
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public FileReaderBuilderDef execute() throws ApiException {
            ApiResponse<FileReaderBuilderDef> localVarResp = putSqlToFileReadDesignWithHttpInfo(determineAvailableSources, body);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToFileReadDesign request with HTTP info returned
         * @return ApiResponse&lt;FileReaderBuilderDef&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<FileReaderBuilderDef> executeWithHttpInfo() throws ApiException {
            return putSqlToFileReadDesignWithHttpInfo(determineAvailableSources, body);
        }

        /**
         * Execute putSqlToFileReadDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<FileReaderBuilderDef> _callback) throws ApiException {
            return putSqlToFileReadDesignAsync(determineAvailableSources, body, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToFileReadDesign: Generates a SQL-file-read-design object from SQL string, if possible.
     * SQL to attempt to create a Design object from
     * @return APIputSqlToFileReadDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToFileReadDesignRequest putSqlToFileReadDesign() {
        return new APIputSqlToFileReadDesignRequest();
    }
    private okhttp3.Call putSqlToQueryDesignCall(String body, Boolean validateWithMetadata, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/todesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (validateWithMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("validateWithMetadata", validateWithMetadata));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToQueryDesignValidateBeforeCall(String body, Boolean validateWithMetadata, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putSqlToQueryDesign(Async)");
        }

        return putSqlToQueryDesignCall(body, validateWithMetadata, _callback);

    }


    private ApiResponse<QueryDesign> putSqlToQueryDesignWithHttpInfo(String body, Boolean validateWithMetadata) throws ApiException {
        okhttp3.Call localVarCall = putSqlToQueryDesignValidateBeforeCall(body, validateWithMetadata, null);
        Type localVarReturnType = new TypeToken<QueryDesign>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToQueryDesignAsync(String body, Boolean validateWithMetadata, final ApiCallback<QueryDesign> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToQueryDesignValidateBeforeCall(body, validateWithMetadata, _callback);
        Type localVarReturnType = new TypeToken<QueryDesign>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToQueryDesignRequest {
        private final String body;
        private Boolean validateWithMetadata;

        private APIputSqlToQueryDesignRequest(String body) {
            this.body = body;
        }

        /**
         * Set validateWithMetadata
         * @param validateWithMetadata Should the table be validated against the users&#39; view of Sys.Field to fill in DataTypes, etc.? (optional, default to true)
         * @return APIputSqlToQueryDesignRequest
         */
        public APIputSqlToQueryDesignRequest validateWithMetadata(Boolean validateWithMetadata) {
            this.validateWithMetadata = validateWithMetadata;
            return this;
        }

        /**
         * Build call for putSqlToQueryDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToQueryDesignCall(body, validateWithMetadata, _callback);
        }

        /**
         * Execute putSqlToQueryDesign request
         * @return QueryDesign
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public QueryDesign execute() throws ApiException {
            ApiResponse<QueryDesign> localVarResp = putSqlToQueryDesignWithHttpInfo(body, validateWithMetadata);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToQueryDesign request with HTTP info returned
         * @return ApiResponse&lt;QueryDesign&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<QueryDesign> executeWithHttpInfo() throws ApiException {
            return putSqlToQueryDesignWithHttpInfo(body, validateWithMetadata);
        }

        /**
         * Execute putSqlToQueryDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<QueryDesign> _callback) throws ApiException {
            return putSqlToQueryDesignAsync(body, validateWithMetadata, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToQueryDesign: Generates a SQL-design object from SQL string, if possible.
     * SQL to attempt to create a Design object from
     * @param body SQL query to generate the design object from (required)
     * @return APIputSqlToQueryDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToQueryDesignRequest putSqlToQueryDesign(String body) {
        return new APIputSqlToQueryDesignRequest(body);
    }
    private okhttp3.Call putSqlToViewDesignCall(String body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/toviewdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToViewDesignValidateBeforeCall(String body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putSqlToViewDesign(Async)");
        }

        return putSqlToViewDesignCall(body, _callback);

    }


    private ApiResponse<ConvertToViewData> putSqlToViewDesignWithHttpInfo(String body) throws ApiException {
        okhttp3.Call localVarCall = putSqlToViewDesignValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<ConvertToViewData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToViewDesignAsync(String body, final ApiCallback<ConvertToViewData> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToViewDesignValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<ConvertToViewData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToViewDesignRequest {
        private final String body;

        private APIputSqlToViewDesignRequest(String body) {
            this.body = body;
        }

        /**
         * Build call for putSqlToViewDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToViewDesignCall(body, _callback);
        }

        /**
         * Execute putSqlToViewDesign request
         * @return ConvertToViewData
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ConvertToViewData execute() throws ApiException {
            ApiResponse<ConvertToViewData> localVarResp = putSqlToViewDesignWithHttpInfo(body);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToViewDesign request with HTTP info returned
         * @return ApiResponse&lt;ConvertToViewData&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConvertToViewData> executeWithHttpInfo() throws ApiException {
            return putSqlToViewDesignWithHttpInfo(body);
        }

        /**
         * Execute putSqlToViewDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConvertToViewData> _callback) throws ApiException {
            return putSqlToViewDesignAsync(body, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToViewDesign: Generates a structured view creation design from existing view creation SQL.
     * SQL which creates a view into a structured ConvertToViewData object
     * @param body SQL Query to generate the ConvertToViewData object from (required)
     * @return APIputSqlToViewDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToViewDesignRequest putSqlToViewDesign(String body) {
        return new APIputSqlToViewDesignRequest(body);
    }
    private okhttp3.Call putSqlToWriterDesignCall(String body, Boolean mergeAdditionalMappingFields, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/towriterdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (mergeAdditionalMappingFields != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mergeAdditionalMappingFields", mergeAdditionalMappingFields));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToWriterDesignValidateBeforeCall(String body, Boolean mergeAdditionalMappingFields, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putSqlToWriterDesign(Async)");
        }

        return putSqlToWriterDesignCall(body, mergeAdditionalMappingFields, _callback);

    }


    private ApiResponse<WriterDesign> putSqlToWriterDesignWithHttpInfo(String body, Boolean mergeAdditionalMappingFields) throws ApiException {
        okhttp3.Call localVarCall = putSqlToWriterDesignValidateBeforeCall(body, mergeAdditionalMappingFields, null);
        Type localVarReturnType = new TypeToken<WriterDesign>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToWriterDesignAsync(String body, Boolean mergeAdditionalMappingFields, final ApiCallback<WriterDesign> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToWriterDesignValidateBeforeCall(body, mergeAdditionalMappingFields, _callback);
        Type localVarReturnType = new TypeToken<WriterDesign>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToWriterDesignRequest {
        private final String body;
        private Boolean mergeAdditionalMappingFields;

        private APIputSqlToWriterDesignRequest(String body) {
            this.body = body;
        }

        /**
         * Set mergeAdditionalMappingFields
         * @param mergeAdditionalMappingFields Should &#x60;Sys.Field&#x60; be used to find additional potential fields to map from? (not always possible) (optional, default to false)
         * @return APIputSqlToWriterDesignRequest
         */
        public APIputSqlToWriterDesignRequest mergeAdditionalMappingFields(Boolean mergeAdditionalMappingFields) {
            this.mergeAdditionalMappingFields = mergeAdditionalMappingFields;
            return this;
        }

        /**
         * Build call for putSqlToWriterDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToWriterDesignCall(body, mergeAdditionalMappingFields, _callback);
        }

        /**
         * Execute putSqlToWriterDesign request
         * @return WriterDesign
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public WriterDesign execute() throws ApiException {
            ApiResponse<WriterDesign> localVarResp = putSqlToWriterDesignWithHttpInfo(body, mergeAdditionalMappingFields);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToWriterDesign request with HTTP info returned
         * @return ApiResponse&lt;WriterDesign&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<WriterDesign> executeWithHttpInfo() throws ApiException {
            return putSqlToWriterDesignWithHttpInfo(body, mergeAdditionalMappingFields);
        }

        /**
         * Execute putSqlToWriterDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<WriterDesign> _callback) throws ApiException {
            return putSqlToWriterDesignAsync(body, mergeAdditionalMappingFields, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToWriterDesign: Generates a SQL-writer-design object from SQL string, if possible.
     * SQL to attempt to create a Writer Design object from
     * @param body SQL query to generate the writer design object from (required)
     * @return APIputSqlToWriterDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToWriterDesignRequest putSqlToWriterDesign(String body) {
        return new APIputSqlToWriterDesignRequest(body);
    }
    private okhttp3.Call putViewDesignToSqlCall(ConvertToViewData convertToViewData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = convertToViewData;

        // create path and map variables
        String localVarPath = "/api/Sql/fromviewdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putViewDesignToSqlValidateBeforeCall(ConvertToViewData convertToViewData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'convertToViewData' is set
        if (convertToViewData == null) {
            throw new ApiException("Missing the required parameter 'convertToViewData' when calling putViewDesignToSql(Async)");
        }

        return putViewDesignToSqlCall(convertToViewData, _callback);

    }


    private ApiResponse<String> putViewDesignToSqlWithHttpInfo(ConvertToViewData convertToViewData) throws ApiException {
        okhttp3.Call localVarCall = putViewDesignToSqlValidateBeforeCall(convertToViewData, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putViewDesignToSqlAsync(ConvertToViewData convertToViewData, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putViewDesignToSqlValidateBeforeCall(convertToViewData, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputViewDesignToSqlRequest {
        private final ConvertToViewData convertToViewData;

        private APIputViewDesignToSqlRequest(ConvertToViewData convertToViewData) {
            this.convertToViewData = convertToViewData;
        }

        /**
         * Build call for putViewDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putViewDesignToSqlCall(convertToViewData, _callback);
        }

        /**
         * Execute putViewDesignToSql request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putViewDesignToSqlWithHttpInfo(convertToViewData);
            return localVarResp.getData();
        }

        /**
         * Execute putViewDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putViewDesignToSqlWithHttpInfo(convertToViewData);
        }

        /**
         * Execute putViewDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putViewDesignToSqlAsync(convertToViewData, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutViewDesignToSql: Generates view creation sql from a structured view creation design
     * Converts a ConvertToView specification into SQL that creates a view
     * @param convertToViewData Structured Query design object to generate SQL from (required)
     * @return APIputViewDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputViewDesignToSqlRequest putViewDesignToSql(ConvertToViewData convertToViewData) {
        return new APIputViewDesignToSqlRequest(convertToViewData);
    }
    private okhttp3.Call putWriterDesignToSqlCall(WriterDesign writerDesign, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = writerDesign;

        // create path and map variables
        String localVarPath = "/api/Sql/fromwriterdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putWriterDesignToSqlValidateBeforeCall(WriterDesign writerDesign, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'writerDesign' is set
        if (writerDesign == null) {
            throw new ApiException("Missing the required parameter 'writerDesign' when calling putWriterDesignToSql(Async)");
        }

        return putWriterDesignToSqlCall(writerDesign, _callback);

    }


    private ApiResponse<String> putWriterDesignToSqlWithHttpInfo(WriterDesign writerDesign) throws ApiException {
        okhttp3.Call localVarCall = putWriterDesignToSqlValidateBeforeCall(writerDesign, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putWriterDesignToSqlAsync(WriterDesign writerDesign, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putWriterDesignToSqlValidateBeforeCall(writerDesign, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputWriterDesignToSqlRequest {
        private final WriterDesign writerDesign;

        private APIputWriterDesignToSqlRequest(WriterDesign writerDesign) {
            this.writerDesign = writerDesign;
        }

        /**
         * Build call for putWriterDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putWriterDesignToSqlCall(writerDesign, _callback);
        }

        /**
         * Execute putWriterDesignToSql request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putWriterDesignToSqlWithHttpInfo(writerDesign);
            return localVarResp.getData();
        }

        /**
         * Execute putWriterDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putWriterDesignToSqlWithHttpInfo(writerDesign);
        }

        /**
         * Execute putWriterDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putWriterDesignToSqlAsync(writerDesign, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutWriterDesignToSql: Generates writer SQL from a valid writer-design structure
     * SQL Writer Design specification to generate Writer SQL from
     * @param writerDesign Structured Writer Design design object to generate Writer SQL from (required)
     * @return APIputWriterDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public APIputWriterDesignToSqlRequest putWriterDesignToSql(WriterDesign writerDesign) {
        return new APIputWriterDesignToSqlRequest(writerDesign);
    }
}
