/*
 * FINBOURNE Luminesce Web API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.luminesce.api;

import com.finbourne.luminesce.ApiCallback;
import com.finbourne.luminesce.ApiClient;
import com.finbourne.luminesce.ApiException;
import com.finbourne.luminesce.ApiResponse;
import com.finbourne.luminesce.Configuration;
import com.finbourne.luminesce.Pair;
import com.finbourne.luminesce.ProgressRequestBody;
import com.finbourne.luminesce.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.finbourne.luminesce.model.ConvertToViewData;
import java.io.File;
import com.finbourne.luminesce.model.FileReaderBuilderDef;
import com.finbourne.luminesce.model.LusidProblemDetails;
import com.finbourne.luminesce.model.QueryDesign;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SqlExecutionApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SqlExecutionApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SqlExecutionApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getByQueryCsvCall(String query, String queryName, Boolean download, Integer timeout, String delimiter, String escape, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/csv/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (delimiter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delimiter", delimiter));
        }

        if (escape != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("escape", escape));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryCsvValidateBeforeCall(String query, String queryName, Boolean download, Integer timeout, String delimiter, String escape, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryCsv(Async)");
        }

        return getByQueryCsvCall(query, queryName, download, timeout, delimiter, escape, _callback);

    }


    private ApiResponse<String> getByQueryCsvWithHttpInfo(String query, String queryName, Boolean download, Integer timeout, String delimiter, String escape) throws ApiException {
        okhttp3.Call localVarCall = getByQueryCsvValidateBeforeCall(query, queryName, download, timeout, delimiter, escape, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQueryCsvAsync(String query, String queryName, Boolean download, Integer timeout, String delimiter, String escape, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQueryCsvValidateBeforeCall(query, queryName, download, timeout, delimiter, escape, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQueryCsvRequest {
        private final String query;
        private String queryName;
        private Boolean download;
        private Integer timeout;
        private String delimiter;
        private String escape;

        private APIgetByQueryCsvRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQueryCsvRequest
         */
        public APIgetByQueryCsvRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set download
         * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
         * @return APIgetByQueryCsvRequest
         */
        public APIgetByQueryCsvRequest download(Boolean download) {
            this.download = download;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQueryCsvRequest
         */
        public APIgetByQueryCsvRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set delimiter
         * @param delimiter Delimiter string to override the default (optional)
         * @return APIgetByQueryCsvRequest
         */
        public APIgetByQueryCsvRequest delimiter(String delimiter) {
            this.delimiter = delimiter;
            return this;
        }

        /**
         * Set escape
         * @param escape Escape character to override the default (optional)
         * @return APIgetByQueryCsvRequest
         */
        public APIgetByQueryCsvRequest escape(String escape) {
            this.escape = escape;
            return this;
        }

        /**
         * Build call for getByQueryCsv
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQueryCsvCall(query, queryName, download, timeout, delimiter, escape, _callback);
        }

        /**
         * Execute getByQueryCsv request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = getByQueryCsvWithHttpInfo(query, queryName, download, timeout, delimiter, escape);
            return localVarResp.getData();
        }

        /**
         * Execute getByQueryCsv request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return getByQueryCsvWithHttpInfo(query, queryName, download, timeout, delimiter, escape);
        }

        /**
         * Execute getByQueryCsv request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return getByQueryCsvAsync(query, queryName, download, timeout, delimiter, escape, _callback);
        }
    }

    /**
     * GetByQueryCsv: Executes Sql, returned in CSV format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQueryCsvRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQueryCsvRequest getByQueryCsv(String query) {
        return new APIgetByQueryCsvRequest(query);
    }
    private okhttp3.Call getByQueryExcelCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/excel/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryExcelValidateBeforeCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryExcel(Async)");
        }

        return getByQueryExcelCall(query, queryName, timeout, _callback);

    }


    private ApiResponse<File> getByQueryExcelWithHttpInfo(String query, String queryName, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryExcelValidateBeforeCall(query, queryName, timeout, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQueryExcelAsync(String query, String queryName, Integer timeout, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQueryExcelValidateBeforeCall(query, queryName, timeout, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQueryExcelRequest {
        private final String query;
        private String queryName;
        private Integer timeout;

        private APIgetByQueryExcelRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQueryExcelRequest
         */
        public APIgetByQueryExcelRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQueryExcelRequest
         */
        public APIgetByQueryExcelRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Build call for getByQueryExcel
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQueryExcelCall(query, queryName, timeout, _callback);
        }

        /**
         * Execute getByQueryExcel request
         * @return File
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public File execute() throws ApiException {
            ApiResponse<File> localVarResp = getByQueryExcelWithHttpInfo(query, queryName, timeout);
            return localVarResp.getData();
        }

        /**
         * Execute getByQueryExcel request with HTTP info returned
         * @return ApiResponse&lt;File&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<File> executeWithHttpInfo() throws ApiException {
            return getByQueryExcelWithHttpInfo(query, queryName, timeout);
        }

        /**
         * Execute getByQueryExcel request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<File> _callback) throws ApiException {
            return getByQueryExcelAsync(query, queryName, timeout, _callback);
        }
    }

    /**
     * GetByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQueryExcelRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQueryExcelRequest getByQueryExcel(String query) {
        return new APIgetByQueryExcelRequest(query);
    }
    private okhttp3.Call getByQueryJsonCall(String query, String queryName, Integer timeout, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/json/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryJsonValidateBeforeCall(String query, String queryName, Integer timeout, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryJson(Async)");
        }

        return getByQueryJsonCall(query, queryName, timeout, jsonProper, _callback);

    }


    private ApiResponse<String> getByQueryJsonWithHttpInfo(String query, String queryName, Integer timeout, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = getByQueryJsonValidateBeforeCall(query, queryName, timeout, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQueryJsonAsync(String query, String queryName, Integer timeout, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQueryJsonValidateBeforeCall(query, queryName, timeout, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQueryJsonRequest {
        private final String query;
        private String queryName;
        private Integer timeout;
        private Boolean jsonProper;

        private APIgetByQueryJsonRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQueryJsonRequest
         */
        public APIgetByQueryJsonRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQueryJsonRequest
         */
        public APIgetByQueryJsonRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Set jsonProper
         * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
         * @return APIgetByQueryJsonRequest
         */
        public APIgetByQueryJsonRequest jsonProper(Boolean jsonProper) {
            this.jsonProper = jsonProper;
            return this;
        }

        /**
         * Build call for getByQueryJson
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQueryJsonCall(query, queryName, timeout, jsonProper, _callback);
        }

        /**
         * Execute getByQueryJson request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = getByQueryJsonWithHttpInfo(query, queryName, timeout, jsonProper);
            return localVarResp.getData();
        }

        /**
         * Execute getByQueryJson request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return getByQueryJsonWithHttpInfo(query, queryName, timeout, jsonProper);
        }

        /**
         * Execute getByQueryJson request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return getByQueryJsonAsync(query, queryName, timeout, jsonProper, _callback);
        }
    }

    /**
     * GetByQueryJson: Executes Sql, returned in JSON format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQueryJsonRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQueryJsonRequest getByQueryJson(String query) {
        return new APIgetByQueryJsonRequest(query);
    }
    private okhttp3.Call getByQueryParquetCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/parquet/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryParquetValidateBeforeCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryParquet(Async)");
        }

        return getByQueryParquetCall(query, queryName, timeout, _callback);

    }


    private ApiResponse<File> getByQueryParquetWithHttpInfo(String query, String queryName, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryParquetValidateBeforeCall(query, queryName, timeout, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQueryParquetAsync(String query, String queryName, Integer timeout, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQueryParquetValidateBeforeCall(query, queryName, timeout, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQueryParquetRequest {
        private final String query;
        private String queryName;
        private Integer timeout;

        private APIgetByQueryParquetRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQueryParquetRequest
         */
        public APIgetByQueryParquetRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQueryParquetRequest
         */
        public APIgetByQueryParquetRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Build call for getByQueryParquet
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQueryParquetCall(query, queryName, timeout, _callback);
        }

        /**
         * Execute getByQueryParquet request
         * @return File
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public File execute() throws ApiException {
            ApiResponse<File> localVarResp = getByQueryParquetWithHttpInfo(query, queryName, timeout);
            return localVarResp.getData();
        }

        /**
         * Execute getByQueryParquet request with HTTP info returned
         * @return ApiResponse&lt;File&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<File> executeWithHttpInfo() throws ApiException {
            return getByQueryParquetWithHttpInfo(query, queryName, timeout);
        }

        /**
         * Execute getByQueryParquet request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<File> _callback) throws ApiException {
            return getByQueryParquetAsync(query, queryName, timeout, _callback);
        }
    }

    /**
     * GetByQueryParquet: Executes Sql, returned in Parquet (.parquet) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQueryParquetRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQueryParquetRequest getByQueryParquet(String query) {
        return new APIgetByQueryParquetRequest(query);
    }
    private okhttp3.Call getByQueryPipeCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/pipe/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryPipeValidateBeforeCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryPipe(Async)");
        }

        return getByQueryPipeCall(query, queryName, download, timeout, _callback);

    }


    private ApiResponse<String> getByQueryPipeWithHttpInfo(String query, String queryName, Boolean download, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryPipeValidateBeforeCall(query, queryName, download, timeout, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQueryPipeAsync(String query, String queryName, Boolean download, Integer timeout, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQueryPipeValidateBeforeCall(query, queryName, download, timeout, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQueryPipeRequest {
        private final String query;
        private String queryName;
        private Boolean download;
        private Integer timeout;

        private APIgetByQueryPipeRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQueryPipeRequest
         */
        public APIgetByQueryPipeRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set download
         * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
         * @return APIgetByQueryPipeRequest
         */
        public APIgetByQueryPipeRequest download(Boolean download) {
            this.download = download;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQueryPipeRequest
         */
        public APIgetByQueryPipeRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Build call for getByQueryPipe
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQueryPipeCall(query, queryName, download, timeout, _callback);
        }

        /**
         * Execute getByQueryPipe request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = getByQueryPipeWithHttpInfo(query, queryName, download, timeout);
            return localVarResp.getData();
        }

        /**
         * Execute getByQueryPipe request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return getByQueryPipeWithHttpInfo(query, queryName, download, timeout);
        }

        /**
         * Execute getByQueryPipe request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return getByQueryPipeAsync(query, queryName, download, timeout, _callback);
        }
    }

    /**
     * GetByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQueryPipeRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQueryPipeRequest getByQueryPipe(String query) {
        return new APIgetByQueryPipeRequest(query);
    }
    private okhttp3.Call getByQuerySqliteCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/sqlite/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQuerySqliteValidateBeforeCall(String query, String queryName, Integer timeout, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQuerySqlite(Async)");
        }

        return getByQuerySqliteCall(query, queryName, timeout, _callback);

    }


    private ApiResponse<File> getByQuerySqliteWithHttpInfo(String query, String queryName, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQuerySqliteValidateBeforeCall(query, queryName, timeout, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQuerySqliteAsync(String query, String queryName, Integer timeout, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQuerySqliteValidateBeforeCall(query, queryName, timeout, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQuerySqliteRequest {
        private final String query;
        private String queryName;
        private Integer timeout;

        private APIgetByQuerySqliteRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQuerySqliteRequest
         */
        public APIgetByQuerySqliteRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQuerySqliteRequest
         */
        public APIgetByQuerySqliteRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Build call for getByQuerySqlite
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQuerySqliteCall(query, queryName, timeout, _callback);
        }

        /**
         * Execute getByQuerySqlite request
         * @return File
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public File execute() throws ApiException {
            ApiResponse<File> localVarResp = getByQuerySqliteWithHttpInfo(query, queryName, timeout);
            return localVarResp.getData();
        }

        /**
         * Execute getByQuerySqlite request with HTTP info returned
         * @return ApiResponse&lt;File&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<File> executeWithHttpInfo() throws ApiException {
            return getByQuerySqliteWithHttpInfo(query, queryName, timeout);
        }

        /**
         * Execute getByQuerySqlite request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<File> _callback) throws ApiException {
            return getByQuerySqliteAsync(query, queryName, timeout, _callback);
        }
    }

    /**
     * GetByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded) format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQuerySqliteRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQuerySqliteRequest getByQuerySqlite(String query) {
        return new APIgetByQuerySqliteRequest(query);
    }
    private okhttp3.Call getByQueryXmlCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/Sql/xml/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByQueryXmlValidateBeforeCall(String query, String queryName, Boolean download, Integer timeout, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling getByQueryXml(Async)");
        }

        return getByQueryXmlCall(query, queryName, download, timeout, _callback);

    }


    private ApiResponse<String> getByQueryXmlWithHttpInfo(String query, String queryName, Boolean download, Integer timeout) throws ApiException {
        okhttp3.Call localVarCall = getByQueryXmlValidateBeforeCall(query, queryName, download, timeout, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByQueryXmlAsync(String query, String queryName, Boolean download, Integer timeout, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByQueryXmlValidateBeforeCall(query, queryName, download, timeout, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetByQueryXmlRequest {
        private final String query;
        private String queryName;
        private Boolean download;
        private Integer timeout;

        private APIgetByQueryXmlRequest(String query) {
            this.query = query;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIgetByQueryXmlRequest
         */
        public APIgetByQueryXmlRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set download
         * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
         * @return APIgetByQueryXmlRequest
         */
        public APIgetByQueryXmlRequest download(Boolean download) {
            this.download = download;
            return this;
        }

        /**
         * Set timeout
         * @param timeout In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIgetByQueryXmlRequest
         */
        public APIgetByQueryXmlRequest timeout(Integer timeout) {
            this.timeout = timeout;
            return this;
        }

        /**
         * Build call for getByQueryXml
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByQueryXmlCall(query, queryName, download, timeout, _callback);
        }

        /**
         * Execute getByQueryXml request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = getByQueryXmlWithHttpInfo(query, queryName, download, timeout);
            return localVarResp.getData();
        }

        /**
         * Execute getByQueryXml request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return getByQueryXmlWithHttpInfo(query, queryName, download, timeout);
        }

        /**
         * Execute getByQueryXml request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return getByQueryXmlAsync(query, queryName, download, timeout, _callback);
        }
    }

    /**
     * GetByQueryXml: Executes Sql, returned in Xml format, where the sql is simply in the url.
     *  For simple single-line query execution via the url. e.g. &#x60;select ^ from Sys.Field order by 1, 2&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param query LuminesceSql to Execute (must be one line only) (required)
     * @return APIgetByQueryXmlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIgetByQueryXmlRequest getByQueryXml(String query) {
        return new APIgetByQueryXmlRequest(query);
    }
    private okhttp3.Call putByQueryCsvCall(String body, String queryName, Boolean download, Integer timeoutSeconds, String delimiter, String escape, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/csv";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        if (delimiter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("delimiter", delimiter));
        }

        if (escape != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("escape", escape));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryCsvValidateBeforeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, String delimiter, String escape, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryCsv(Async)");
        }

        return putByQueryCsvCall(body, queryName, download, timeoutSeconds, delimiter, escape, _callback);

    }


    private ApiResponse<String> putByQueryCsvWithHttpInfo(String body, String queryName, Boolean download, Integer timeoutSeconds, String delimiter, String escape) throws ApiException {
        okhttp3.Call localVarCall = putByQueryCsvValidateBeforeCall(body, queryName, download, timeoutSeconds, delimiter, escape, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQueryCsvAsync(String body, String queryName, Boolean download, Integer timeoutSeconds, String delimiter, String escape, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQueryCsvValidateBeforeCall(body, queryName, download, timeoutSeconds, delimiter, escape, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQueryCsvRequest {
        private final String body;
        private String queryName;
        private Boolean download;
        private Integer timeoutSeconds;
        private String delimiter;
        private String escape;

        private APIputByQueryCsvRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQueryCsvRequest
         */
        public APIputByQueryCsvRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set download
         * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
         * @return APIputByQueryCsvRequest
         */
        public APIputByQueryCsvRequest download(Boolean download) {
            this.download = download;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQueryCsvRequest
         */
        public APIputByQueryCsvRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Set delimiter
         * @param delimiter Delimiter string to override the default (optional)
         * @return APIputByQueryCsvRequest
         */
        public APIputByQueryCsvRequest delimiter(String delimiter) {
            this.delimiter = delimiter;
            return this;
        }

        /**
         * Set escape
         * @param escape Escape character to override the default (optional)
         * @return APIputByQueryCsvRequest
         */
        public APIputByQueryCsvRequest escape(String escape) {
            this.escape = escape;
            return this;
        }

        /**
         * Build call for putByQueryCsv
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQueryCsvCall(body, queryName, download, timeoutSeconds, delimiter, escape, _callback);
        }

        /**
         * Execute putByQueryCsv request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putByQueryCsvWithHttpInfo(body, queryName, download, timeoutSeconds, delimiter, escape);
            return localVarResp.getData();
        }

        /**
         * Execute putByQueryCsv request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putByQueryCsvWithHttpInfo(body, queryName, download, timeoutSeconds, delimiter, escape);
        }

        /**
         * Execute putByQueryCsv request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putByQueryCsvAsync(body, queryName, download, timeoutSeconds, delimiter, escape, _callback);
        }
    }

    /**
     * PutByQueryCsv: Executes Sql, returned in CSV format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQueryCsvRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQueryCsvRequest putByQueryCsv(String body) {
        return new APIputByQueryCsvRequest(body);
    }
    private okhttp3.Call putByQueryExcelCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/excel";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryExcelValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryExcel(Async)");
        }

        return putByQueryExcelCall(body, queryName, timeoutSeconds, _callback);

    }


    private ApiResponse<File> putByQueryExcelWithHttpInfo(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryExcelValidateBeforeCall(body, queryName, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQueryExcelAsync(String body, String queryName, Integer timeoutSeconds, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQueryExcelValidateBeforeCall(body, queryName, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQueryExcelRequest {
        private final String body;
        private String queryName;
        private Integer timeoutSeconds;

        private APIputByQueryExcelRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQueryExcelRequest
         */
        public APIputByQueryExcelRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQueryExcelRequest
         */
        public APIputByQueryExcelRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Build call for putByQueryExcel
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQueryExcelCall(body, queryName, timeoutSeconds, _callback);
        }

        /**
         * Execute putByQueryExcel request
         * @return File
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public File execute() throws ApiException {
            ApiResponse<File> localVarResp = putByQueryExcelWithHttpInfo(body, queryName, timeoutSeconds);
            return localVarResp.getData();
        }

        /**
         * Execute putByQueryExcel request with HTTP info returned
         * @return ApiResponse&lt;File&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<File> executeWithHttpInfo() throws ApiException {
            return putByQueryExcelWithHttpInfo(body, queryName, timeoutSeconds);
        }

        /**
         * Execute putByQueryExcel request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<File> _callback) throws ApiException {
            return putByQueryExcelAsync(body, queryName, timeoutSeconds, _callback);
        }
    }

    /**
     * PutByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded), where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQueryExcelRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQueryExcelRequest putByQueryExcel(String body) {
        return new APIputByQueryExcelRequest(body);
    }
    private okhttp3.Call putByQueryJsonCall(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryJsonValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryJson(Async)");
        }

        return putByQueryJsonCall(body, queryName, timeoutSeconds, jsonProper, _callback);

    }


    private ApiResponse<String> putByQueryJsonWithHttpInfo(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = putByQueryJsonValidateBeforeCall(body, queryName, timeoutSeconds, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQueryJsonAsync(String body, String queryName, Integer timeoutSeconds, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQueryJsonValidateBeforeCall(body, queryName, timeoutSeconds, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQueryJsonRequest {
        private final String body;
        private String queryName;
        private Integer timeoutSeconds;
        private Boolean jsonProper;

        private APIputByQueryJsonRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQueryJsonRequest
         */
        public APIputByQueryJsonRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQueryJsonRequest
         */
        public APIputByQueryJsonRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Set jsonProper
         * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
         * @return APIputByQueryJsonRequest
         */
        public APIputByQueryJsonRequest jsonProper(Boolean jsonProper) {
            this.jsonProper = jsonProper;
            return this;
        }

        /**
         * Build call for putByQueryJson
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQueryJsonCall(body, queryName, timeoutSeconds, jsonProper, _callback);
        }

        /**
         * Execute putByQueryJson request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putByQueryJsonWithHttpInfo(body, queryName, timeoutSeconds, jsonProper);
            return localVarResp.getData();
        }

        /**
         * Execute putByQueryJson request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putByQueryJsonWithHttpInfo(body, queryName, timeoutSeconds, jsonProper);
        }

        /**
         * Execute putByQueryJson request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putByQueryJsonAsync(body, queryName, timeoutSeconds, jsonProper, _callback);
        }
    }

    /**
     * PutByQueryJson: Executes Sql, returned in JSON format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQueryJsonRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQueryJsonRequest putByQueryJson(String body) {
        return new APIputByQueryJsonRequest(body);
    }
    private okhttp3.Call putByQueryParquetCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/parquet";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryParquetValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryParquet(Async)");
        }

        return putByQueryParquetCall(body, queryName, timeoutSeconds, _callback);

    }


    private ApiResponse<File> putByQueryParquetWithHttpInfo(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryParquetValidateBeforeCall(body, queryName, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQueryParquetAsync(String body, String queryName, Integer timeoutSeconds, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQueryParquetValidateBeforeCall(body, queryName, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQueryParquetRequest {
        private final String body;
        private String queryName;
        private Integer timeoutSeconds;

        private APIputByQueryParquetRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQueryParquetRequest
         */
        public APIputByQueryParquetRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQueryParquetRequest
         */
        public APIputByQueryParquetRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Build call for putByQueryParquet
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQueryParquetCall(body, queryName, timeoutSeconds, _callback);
        }

        /**
         * Execute putByQueryParquet request
         * @return File
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public File execute() throws ApiException {
            ApiResponse<File> localVarResp = putByQueryParquetWithHttpInfo(body, queryName, timeoutSeconds);
            return localVarResp.getData();
        }

        /**
         * Execute putByQueryParquet request with HTTP info returned
         * @return ApiResponse&lt;File&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<File> executeWithHttpInfo() throws ApiException {
            return putByQueryParquetWithHttpInfo(body, queryName, timeoutSeconds);
        }

        /**
         * Execute putByQueryParquet request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<File> _callback) throws ApiException {
            return putByQueryParquetAsync(body, queryName, timeoutSeconds, _callback);
        }
    }

    /**
     * PutByQueryParquet: Executes Sql, returned in Parquet format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQueryParquetRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQueryParquetRequest putByQueryParquet(String body) {
        return new APIputByQueryParquetRequest(body);
    }
    private okhttp3.Call putByQueryPipeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/pipe";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryPipeValidateBeforeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryPipe(Async)");
        }

        return putByQueryPipeCall(body, queryName, download, timeoutSeconds, _callback);

    }


    private ApiResponse<String> putByQueryPipeWithHttpInfo(String body, String queryName, Boolean download, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryPipeValidateBeforeCall(body, queryName, download, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQueryPipeAsync(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQueryPipeValidateBeforeCall(body, queryName, download, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQueryPipeRequest {
        private final String body;
        private String queryName;
        private Boolean download;
        private Integer timeoutSeconds;

        private APIputByQueryPipeRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQueryPipeRequest
         */
        public APIputByQueryPipeRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set download
         * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
         * @return APIputByQueryPipeRequest
         */
        public APIputByQueryPipeRequest download(Boolean download) {
            this.download = download;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQueryPipeRequest
         */
        public APIputByQueryPipeRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Build call for putByQueryPipe
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQueryPipeCall(body, queryName, download, timeoutSeconds, _callback);
        }

        /**
         * Execute putByQueryPipe request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putByQueryPipeWithHttpInfo(body, queryName, download, timeoutSeconds);
            return localVarResp.getData();
        }

        /**
         * Execute putByQueryPipe request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putByQueryPipeWithHttpInfo(body, queryName, download, timeoutSeconds);
        }

        /**
         * Execute putByQueryPipe request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putByQueryPipeAsync(body, queryName, download, timeoutSeconds, _callback);
        }
    }

    /**
     * PutByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQueryPipeRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQueryPipeRequest putByQueryPipe(String body) {
        return new APIputByQueryPipeRequest(body);
    }
    private okhttp3.Call putByQuerySqliteCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/sqlite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQuerySqliteValidateBeforeCall(String body, String queryName, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQuerySqlite(Async)");
        }

        return putByQuerySqliteCall(body, queryName, timeoutSeconds, _callback);

    }


    private ApiResponse<File> putByQuerySqliteWithHttpInfo(String body, String queryName, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQuerySqliteValidateBeforeCall(body, queryName, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQuerySqliteAsync(String body, String queryName, Integer timeoutSeconds, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQuerySqliteValidateBeforeCall(body, queryName, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQuerySqliteRequest {
        private final String body;
        private String queryName;
        private Integer timeoutSeconds;

        private APIputByQuerySqliteRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQuerySqliteRequest
         */
        public APIputByQuerySqliteRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQuerySqliteRequest
         */
        public APIputByQuerySqliteRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Build call for putByQuerySqlite
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQuerySqliteCall(body, queryName, timeoutSeconds, _callback);
        }

        /**
         * Execute putByQuerySqlite request
         * @return File
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public File execute() throws ApiException {
            ApiResponse<File> localVarResp = putByQuerySqliteWithHttpInfo(body, queryName, timeoutSeconds);
            return localVarResp.getData();
        }

        /**
         * Execute putByQuerySqlite request with HTTP info returned
         * @return ApiResponse&lt;File&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<File> executeWithHttpInfo() throws ApiException {
            return putByQuerySqliteWithHttpInfo(body, queryName, timeoutSeconds);
        }

        /**
         * Execute putByQuerySqlite request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<File> _callback) throws ApiException {
            return putByQuerySqliteAsync(body, queryName, timeoutSeconds, _callback);
        }
    }

    /**
     * PutByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded), where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQuerySqliteRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQuerySqliteRequest putByQuerySqlite(String body) {
        return new APIputByQuerySqliteRequest(body);
    }
    private okhttp3.Call putByQueryXmlCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/xml";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (queryName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("queryName", queryName));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (timeoutSeconds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeoutSeconds", timeoutSeconds));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putByQueryXmlValidateBeforeCall(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putByQueryXml(Async)");
        }

        return putByQueryXmlCall(body, queryName, download, timeoutSeconds, _callback);

    }


    private ApiResponse<String> putByQueryXmlWithHttpInfo(String body, String queryName, Boolean download, Integer timeoutSeconds) throws ApiException {
        okhttp3.Call localVarCall = putByQueryXmlValidateBeforeCall(body, queryName, download, timeoutSeconds, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putByQueryXmlAsync(String body, String queryName, Boolean download, Integer timeoutSeconds, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putByQueryXmlValidateBeforeCall(body, queryName, download, timeoutSeconds, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputByQueryXmlRequest {
        private final String body;
        private String queryName;
        private Boolean download;
        private Integer timeoutSeconds;

        private APIputByQueryXmlRequest(String body) {
            this.body = body;
        }

        /**
         * Set queryName
         * @param queryName Name to apply to the query in logs and &#x60;Sys.Logs.HcQueryStart&#x60; (optional)
         * @return APIputByQueryXmlRequest
         */
        public APIputByQueryXmlRequest queryName(String queryName) {
            this.queryName = queryName;
            return this;
        }

        /**
         * Set download
         * @param download Makes this a file-download request (as opposed to returning the data in the response-body) (optional, default to false)
         * @return APIputByQueryXmlRequest
         */
        public APIputByQueryXmlRequest download(Boolean download) {
            this.download = download;
            return this;
        }

        /**
         * Set timeoutSeconds
         * @param timeoutSeconds In seconds: &lt;0 → ∞, 0 → 120s (optional, default to 0)
         * @return APIputByQueryXmlRequest
         */
        public APIputByQueryXmlRequest timeoutSeconds(Integer timeoutSeconds) {
            this.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * Build call for putByQueryXml
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putByQueryXmlCall(body, queryName, download, timeoutSeconds, _callback);
        }

        /**
         * Execute putByQueryXml request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putByQueryXmlWithHttpInfo(body, queryName, download, timeoutSeconds);
            return localVarResp.getData();
        }

        /**
         * Execute putByQueryXml request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putByQueryXmlWithHttpInfo(body, queryName, download, timeoutSeconds);
        }

        /**
         * Execute putByQueryXml request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putByQueryXmlAsync(body, queryName, download, timeoutSeconds, _callback);
        }
    }

    /**
     * PutByQueryXml: Executes Sql, returned in Xml format, where the sql is the post-body url.
     *  For more complex LuminesceSql a PUT will allow for longer Sql. e.g.: &#x60;&#x60;&#x60;sql @@cutoff &#x3D; select #2020-02-01#; @issues &#x3D; select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project&#x3D;&#39;HC&#39; and Created &lt; @@cutoff and Updated &gt; @@cutoff;  select i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary from @issues i inner join Dev.Jira.Issue.Link li  on i.Id &#x3D; li.IssueId &#x60;&#x60;&#x60;  The following error codes are to be anticipated with standard Problem Detail reports: - 400 BadRequest - something failed with the execution or parsing of your query - 401 Unauthorized 
     * @param body LuminesceSql to Execute (may be multi-line) (required)
     * @return APIputByQueryXmlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputByQueryXmlRequest putByQueryXml(String body) {
        return new APIputByQueryXmlRequest(body);
    }
    private okhttp3.Call putFileReadDesignToSqlCall(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fileReaderBuilderDef;

        // create path and map variables
        String localVarPath = "/api/Sql/fromfilereaddesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (executeQuery != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("executeQuery", executeQuery));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putFileReadDesignToSqlValidateBeforeCall(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fileReaderBuilderDef' is set
        if (fileReaderBuilderDef == null) {
            throw new ApiException("Missing the required parameter 'fileReaderBuilderDef' when calling putFileReadDesignToSql(Async)");
        }

        return putFileReadDesignToSqlCall(fileReaderBuilderDef, executeQuery, _callback);

    }


    private ApiResponse<String> putFileReadDesignToSqlWithHttpInfo(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery) throws ApiException {
        okhttp3.Call localVarCall = putFileReadDesignToSqlValidateBeforeCall(fileReaderBuilderDef, executeQuery, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putFileReadDesignToSqlAsync(FileReaderBuilderDef fileReaderBuilderDef, Boolean executeQuery, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putFileReadDesignToSqlValidateBeforeCall(fileReaderBuilderDef, executeQuery, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputFileReadDesignToSqlRequest {
        private final FileReaderBuilderDef fileReaderBuilderDef;
        private Boolean executeQuery;

        private APIputFileReadDesignToSqlRequest(FileReaderBuilderDef fileReaderBuilderDef) {
            this.fileReaderBuilderDef = fileReaderBuilderDef;
        }

        /**
         * Set executeQuery
         * @param executeQuery Should the generated query be executed to build preview data or determine errors.&gt; (optional, default to true)
         * @return APIputFileReadDesignToSqlRequest
         */
        public APIputFileReadDesignToSqlRequest executeQuery(Boolean executeQuery) {
            this.executeQuery = executeQuery;
            return this;
        }

        /**
         * Build call for putFileReadDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putFileReadDesignToSqlCall(fileReaderBuilderDef, executeQuery, _callback);
        }

        /**
         * Execute putFileReadDesignToSql request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putFileReadDesignToSqlWithHttpInfo(fileReaderBuilderDef, executeQuery);
            return localVarResp.getData();
        }

        /**
         * Execute putFileReadDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putFileReadDesignToSqlWithHttpInfo(fileReaderBuilderDef, executeQuery);
        }

        /**
         * Execute putFileReadDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putFileReadDesignToSqlAsync(fileReaderBuilderDef, executeQuery, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutFileReadDesignToSql: Generates file read SQL from a structured query design
     * SQL Designer specification to generate SQL from
     * @param fileReaderBuilderDef Structured file read design object to generate SQL from (required)
     * @return APIputFileReadDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputFileReadDesignToSqlRequest putFileReadDesignToSql(FileReaderBuilderDef fileReaderBuilderDef) {
        return new APIputFileReadDesignToSqlRequest(fileReaderBuilderDef);
    }
    private okhttp3.Call putQueryDesignToSqlCall(QueryDesign queryDesign, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = queryDesign;

        // create path and map variables
        String localVarPath = "/api/Sql/fromdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putQueryDesignToSqlValidateBeforeCall(QueryDesign queryDesign, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'queryDesign' is set
        if (queryDesign == null) {
            throw new ApiException("Missing the required parameter 'queryDesign' when calling putQueryDesignToSql(Async)");
        }

        return putQueryDesignToSqlCall(queryDesign, _callback);

    }


    private ApiResponse<String> putQueryDesignToSqlWithHttpInfo(QueryDesign queryDesign) throws ApiException {
        okhttp3.Call localVarCall = putQueryDesignToSqlValidateBeforeCall(queryDesign, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putQueryDesignToSqlAsync(QueryDesign queryDesign, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putQueryDesignToSqlValidateBeforeCall(queryDesign, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputQueryDesignToSqlRequest {
        private final QueryDesign queryDesign;

        private APIputQueryDesignToSqlRequest(QueryDesign queryDesign) {
            this.queryDesign = queryDesign;
        }

        /**
         * Build call for putQueryDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putQueryDesignToSqlCall(queryDesign, _callback);
        }

        /**
         * Execute putQueryDesignToSql request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putQueryDesignToSqlWithHttpInfo(queryDesign);
            return localVarResp.getData();
        }

        /**
         * Execute putQueryDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putQueryDesignToSqlWithHttpInfo(queryDesign);
        }

        /**
         * Execute putQueryDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putQueryDesignToSqlAsync(queryDesign, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutQueryDesignToSql: Generates SQL from a structured query design
     * SQL Designer specification to generate SQL from
     * @param queryDesign Structured Query design object to generate SQL from (required)
     * @return APIputQueryDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputQueryDesignToSqlRequest putQueryDesignToSql(QueryDesign queryDesign) {
        return new APIputQueryDesignToSqlRequest(queryDesign);
    }
    private okhttp3.Call putQueryToFormatCall(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/pretty";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trailingCommas != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trailingCommas", trailingCommas));
        }

        if (uppercaseKeywords != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("uppercaseKeywords", uppercaseKeywords));
        }

        if (breakJoinOnSections != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakJoinOnSections", breakJoinOnSections));
        }

        if (spaceAfterExpandedComma != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("spaceAfterExpandedComma", spaceAfterExpandedComma));
        }

        if (keywordStandardization != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keywordStandardization", keywordStandardization));
        }

        if (expandCommaLists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandCommaLists", expandCommaLists));
        }

        if (expandInLists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandInLists", expandInLists));
        }

        if (expandBooleanExpressions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandBooleanExpressions", expandBooleanExpressions));
        }

        if (expandBetweenConditions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandBetweenConditions", expandBetweenConditions));
        }

        if (expandCaseStatements != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expandCaseStatements", expandCaseStatements));
        }

        if (maxLineWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxLineWidth", maxLineWidth));
        }

        if (spaceBeforeTrailingSingleLineComments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("spaceBeforeTrailingSingleLineComments", spaceBeforeTrailingSingleLineComments));
        }

        if (multilineCommentExtraLineBreak != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("multilineCommentExtraLineBreak", multilineCommentExtraLineBreak));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putQueryToFormatValidateBeforeCall(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putQueryToFormat(Async)");
        }

        return putQueryToFormatCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);

    }


    private ApiResponse<String> putQueryToFormatWithHttpInfo(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak) throws ApiException {
        okhttp3.Call localVarCall = putQueryToFormatValidateBeforeCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putQueryToFormatAsync(String body, Boolean trailingCommas, Boolean uppercaseKeywords, Boolean breakJoinOnSections, Boolean spaceAfterExpandedComma, Boolean keywordStandardization, Boolean expandCommaLists, Boolean expandInLists, Boolean expandBooleanExpressions, Boolean expandBetweenConditions, Boolean expandCaseStatements, Integer maxLineWidth, Boolean spaceBeforeTrailingSingleLineComments, Boolean multilineCommentExtraLineBreak, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putQueryToFormatValidateBeforeCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputQueryToFormatRequest {
        private final String body;
        private Boolean trailingCommas;
        private Boolean uppercaseKeywords;
        private Boolean breakJoinOnSections;
        private Boolean spaceAfterExpandedComma;
        private Boolean keywordStandardization;
        private Boolean expandCommaLists;
        private Boolean expandInLists;
        private Boolean expandBooleanExpressions;
        private Boolean expandBetweenConditions;
        private Boolean expandCaseStatements;
        private Integer maxLineWidth;
        private Boolean spaceBeforeTrailingSingleLineComments;
        private Boolean multilineCommentExtraLineBreak;

        private APIputQueryToFormatRequest(String body) {
            this.body = body;
        }

        /**
         * Set trailingCommas
         * @param trailingCommas Should commas be after an expression (as opposed to before) (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest trailingCommas(Boolean trailingCommas) {
            this.trailingCommas = trailingCommas;
            return this;
        }

        /**
         * Set uppercaseKeywords
         * @param uppercaseKeywords Should key words be capitalized (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest uppercaseKeywords(Boolean uppercaseKeywords) {
            this.uppercaseKeywords = uppercaseKeywords;
            return this;
        }

        /**
         * Set breakJoinOnSections
         * @param breakJoinOnSections Should clauses on joins be given line breaks? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest breakJoinOnSections(Boolean breakJoinOnSections) {
            this.breakJoinOnSections = breakJoinOnSections;
            return this;
        }

        /**
         * Set spaceAfterExpandedComma
         * @param spaceAfterExpandedComma Should comma-lists have spaces after the commas? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest spaceAfterExpandedComma(Boolean spaceAfterExpandedComma) {
            this.spaceAfterExpandedComma = spaceAfterExpandedComma;
            return this;
        }

        /**
         * Set keywordStandardization
         * @param keywordStandardization Should the \&quot;nicest\&quot; key words be used? (e.g. JOIN -&gt; INNER JOIN) (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest keywordStandardization(Boolean keywordStandardization) {
            this.keywordStandardization = keywordStandardization;
            return this;
        }

        /**
         * Set expandCommaLists
         * @param expandCommaLists Should comma-lists (e.g. select a,b,c) have line breaks added? (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandCommaLists(Boolean expandCommaLists) {
            this.expandCommaLists = expandCommaLists;
            return this;
        }

        /**
         * Set expandInLists
         * @param expandInLists Should IN-lists have line breaks added? (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandInLists(Boolean expandInLists) {
            this.expandInLists = expandInLists;
            return this;
        }

        /**
         * Set expandBooleanExpressions
         * @param expandBooleanExpressions Should boolean expressions have line breaks added? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandBooleanExpressions(Boolean expandBooleanExpressions) {
            this.expandBooleanExpressions = expandBooleanExpressions;
            return this;
        }

        /**
         * Set expandBetweenConditions
         * @param expandBetweenConditions Should between conditions have line breaks added? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandBetweenConditions(Boolean expandBetweenConditions) {
            this.expandBetweenConditions = expandBetweenConditions;
            return this;
        }

        /**
         * Set expandCaseStatements
         * @param expandCaseStatements Should case-statements have line breaks added? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest expandCaseStatements(Boolean expandCaseStatements) {
            this.expandCaseStatements = expandCaseStatements;
            return this;
        }

        /**
         * Set maxLineWidth
         * @param maxLineWidth Maximum number of characters to allow on one line (if possible) (optional, default to 120)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest maxLineWidth(Integer maxLineWidth) {
            this.maxLineWidth = maxLineWidth;
            return this;
        }

        /**
         * Set spaceBeforeTrailingSingleLineComments
         * @param spaceBeforeTrailingSingleLineComments Should the be a space before trailing single line comments? (optional, default to true)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest spaceBeforeTrailingSingleLineComments(Boolean spaceBeforeTrailingSingleLineComments) {
            this.spaceBeforeTrailingSingleLineComments = spaceBeforeTrailingSingleLineComments;
            return this;
        }

        /**
         * Set multilineCommentExtraLineBreak
         * @param multilineCommentExtraLineBreak Should an additional line break be added after multi-line comments? (optional, default to false)
         * @return APIputQueryToFormatRequest
         */
        public APIputQueryToFormatRequest multilineCommentExtraLineBreak(Boolean multilineCommentExtraLineBreak) {
            this.multilineCommentExtraLineBreak = multilineCommentExtraLineBreak;
            return this;
        }

        /**
         * Build call for putQueryToFormat
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putQueryToFormatCall(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);
        }

        /**
         * Execute putQueryToFormat request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putQueryToFormatWithHttpInfo(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak);
            return localVarResp.getData();
        }

        /**
         * Execute putQueryToFormat request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putQueryToFormatWithHttpInfo(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak);
        }

        /**
         * Execute putQueryToFormat request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putQueryToFormatAsync(body, trailingCommas, uppercaseKeywords, breakJoinOnSections, spaceAfterExpandedComma, keywordStandardization, expandCommaLists, expandInLists, expandBooleanExpressions, expandBetweenConditions, expandCaseStatements, maxLineWidth, spaceBeforeTrailingSingleLineComments, multilineCommentExtraLineBreak, _callback);
        }
    }

    /**
     * PutQueryToFormat: Executes Sql, returned in JSON format, where the sql is the post-body url.
     *  This formats SQL (given a set of options as to how to do so). It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. &#x60;&#x60;&#x60;sql select x,y,z from a inner join b on a.x&#x3D;b.x where x&gt;y or y!&#x3D;z &#x60;&#x60;&#x60; becomes &#x60;&#x60;&#x60;sql select x, y, z from a inner join b  on a.x &#x3D; b.x where x &gt; y  or y !&#x3D; z &#x60;&#x60;&#x60; 
     * @param body LuminesceSql to Pretty-Print. Even if it doesn&#39;t parse an attempt will be made to format it (required)
     * @return APIputQueryToFormatRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputQueryToFormatRequest putQueryToFormat(String body) {
        return new APIputQueryToFormatRequest(body);
    }
    private okhttp3.Call putSqlToFileReadDesignCall(Boolean determineAvailableSources, String body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/tofilereaddesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (determineAvailableSources != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("determineAvailableSources", determineAvailableSources));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToFileReadDesignValidateBeforeCall(Boolean determineAvailableSources, String body, final ApiCallback _callback) throws ApiException {
        return putSqlToFileReadDesignCall(determineAvailableSources, body, _callback);

    }


    private ApiResponse<String> putSqlToFileReadDesignWithHttpInfo(Boolean determineAvailableSources, String body) throws ApiException {
        okhttp3.Call localVarCall = putSqlToFileReadDesignValidateBeforeCall(determineAvailableSources, body, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToFileReadDesignAsync(Boolean determineAvailableSources, String body, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToFileReadDesignValidateBeforeCall(determineAvailableSources, body, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToFileReadDesignRequest {
        private Boolean determineAvailableSources;
        private String body;

        private APIputSqlToFileReadDesignRequest() {
        }

        /**
         * Set determineAvailableSources
         * @param determineAvailableSources Should the available sources be determined from &#x60;Sys.Registration&#x60; (optional, default to true)
         * @return APIputSqlToFileReadDesignRequest
         */
        public APIputSqlToFileReadDesignRequest determineAvailableSources(Boolean determineAvailableSources) {
            this.determineAvailableSources = determineAvailableSources;
            return this;
        }

        /**
         * Set body
         * @param body SQL query to generate the file read design object from (optional)
         * @return APIputSqlToFileReadDesignRequest
         */
        public APIputSqlToFileReadDesignRequest body(String body) {
            this.body = body;
            return this;
        }

        /**
         * Build call for putSqlToFileReadDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToFileReadDesignCall(determineAvailableSources, body, _callback);
        }

        /**
         * Execute putSqlToFileReadDesign request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putSqlToFileReadDesignWithHttpInfo(determineAvailableSources, body);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToFileReadDesign request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putSqlToFileReadDesignWithHttpInfo(determineAvailableSources, body);
        }

        /**
         * Execute putSqlToFileReadDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putSqlToFileReadDesignAsync(determineAvailableSources, body, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToFileReadDesign: Generates a SQL-file-read-design object from SQL string, if possible.
     * SQL to attempt to create a Design object from
     * @return APIputSqlToFileReadDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToFileReadDesignRequest putSqlToFileReadDesign() {
        return new APIputSqlToFileReadDesignRequest();
    }
    private okhttp3.Call putSqlToQueryDesignCall(String body, Boolean validateWithMetadata, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/todesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (validateWithMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("validateWithMetadata", validateWithMetadata));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToQueryDesignValidateBeforeCall(String body, Boolean validateWithMetadata, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putSqlToQueryDesign(Async)");
        }

        return putSqlToQueryDesignCall(body, validateWithMetadata, _callback);

    }


    private ApiResponse<String> putSqlToQueryDesignWithHttpInfo(String body, Boolean validateWithMetadata) throws ApiException {
        okhttp3.Call localVarCall = putSqlToQueryDesignValidateBeforeCall(body, validateWithMetadata, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToQueryDesignAsync(String body, Boolean validateWithMetadata, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToQueryDesignValidateBeforeCall(body, validateWithMetadata, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToQueryDesignRequest {
        private final String body;
        private Boolean validateWithMetadata;

        private APIputSqlToQueryDesignRequest(String body) {
            this.body = body;
        }

        /**
         * Set validateWithMetadata
         * @param validateWithMetadata Should the table be validated against the users&#39; view of Sys.Field to fill in DataTypes, etc.? (optional, default to true)
         * @return APIputSqlToQueryDesignRequest
         */
        public APIputSqlToQueryDesignRequest validateWithMetadata(Boolean validateWithMetadata) {
            this.validateWithMetadata = validateWithMetadata;
            return this;
        }

        /**
         * Build call for putSqlToQueryDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToQueryDesignCall(body, validateWithMetadata, _callback);
        }

        /**
         * Execute putSqlToQueryDesign request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putSqlToQueryDesignWithHttpInfo(body, validateWithMetadata);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToQueryDesign request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putSqlToQueryDesignWithHttpInfo(body, validateWithMetadata);
        }

        /**
         * Execute putSqlToQueryDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putSqlToQueryDesignAsync(body, validateWithMetadata, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToQueryDesign: Generates a SQL-design object from SQL string, if possible.
     * SQL to attempt to create a Design object from
     * @param body SQL query to generate the design object from (required)
     * @return APIputSqlToQueryDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToQueryDesignRequest putSqlToQueryDesign(String body) {
        return new APIputSqlToQueryDesignRequest(body);
    }
    private okhttp3.Call putSqlToViewDesignCall(String body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/Sql/toviewdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putSqlToViewDesignValidateBeforeCall(String body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling putSqlToViewDesign(Async)");
        }

        return putSqlToViewDesignCall(body, _callback);

    }


    private ApiResponse<String> putSqlToViewDesignWithHttpInfo(String body) throws ApiException {
        okhttp3.Call localVarCall = putSqlToViewDesignValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putSqlToViewDesignAsync(String body, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putSqlToViewDesignValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputSqlToViewDesignRequest {
        private final String body;

        private APIputSqlToViewDesignRequest(String body) {
            this.body = body;
        }

        /**
         * Build call for putSqlToViewDesign
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putSqlToViewDesignCall(body, _callback);
        }

        /**
         * Execute putSqlToViewDesign request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putSqlToViewDesignWithHttpInfo(body);
            return localVarResp.getData();
        }

        /**
         * Execute putSqlToViewDesign request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putSqlToViewDesignWithHttpInfo(body);
        }

        /**
         * Execute putSqlToViewDesign request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putSqlToViewDesignAsync(body, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutSqlToViewDesign: Generates a structured view creation design from existing view creation SQL.
     * SQL which creates a view into a structured ConvertToViewData object
     * @param body SQL Query to generate the ConvertToViewData object from (required)
     * @return APIputSqlToViewDesignRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputSqlToViewDesignRequest putSqlToViewDesign(String body) {
        return new APIputSqlToViewDesignRequest(body);
    }
    private okhttp3.Call putViewDesignToSqlCall(ConvertToViewData convertToViewData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = convertToViewData;

        // create path and map variables
        String localVarPath = "/api/Sql/fromviewdesign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json-patch+json",
            "application/json",
            "text/json",
            "application/*+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call putViewDesignToSqlValidateBeforeCall(ConvertToViewData convertToViewData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'convertToViewData' is set
        if (convertToViewData == null) {
            throw new ApiException("Missing the required parameter 'convertToViewData' when calling putViewDesignToSql(Async)");
        }

        return putViewDesignToSqlCall(convertToViewData, _callback);

    }


    private ApiResponse<String> putViewDesignToSqlWithHttpInfo(ConvertToViewData convertToViewData) throws ApiException {
        okhttp3.Call localVarCall = putViewDesignToSqlValidateBeforeCall(convertToViewData, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call putViewDesignToSqlAsync(ConvertToViewData convertToViewData, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = putViewDesignToSqlValidateBeforeCall(convertToViewData, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIputViewDesignToSqlRequest {
        private final ConvertToViewData convertToViewData;

        private APIputViewDesignToSqlRequest(ConvertToViewData convertToViewData) {
            this.convertToViewData = convertToViewData;
        }

        /**
         * Build call for putViewDesignToSql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return putViewDesignToSqlCall(convertToViewData, _callback);
        }

        /**
         * Execute putViewDesignToSql request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = putViewDesignToSqlWithHttpInfo(convertToViewData);
            return localVarResp.getData();
        }

        /**
         * Execute putViewDesignToSql request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return putViewDesignToSqlWithHttpInfo(convertToViewData);
        }

        /**
         * Execute putViewDesignToSql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return putViewDesignToSqlAsync(convertToViewData, _callback);
        }
    }

    /**
     * [EXPERIMENTAL] PutViewDesignToSql: Generates view creation sql from a structured view creation design
     * Converts a ConvertToView specification into SQL that creates a view
     * @param convertToViewData Structured Query design object to generate SQL from (required)
     * @return APIputViewDesignToSqlRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIputViewDesignToSqlRequest putViewDesignToSql(ConvertToViewData convertToViewData) {
        return new APIputViewDesignToSqlRequest(convertToViewData);
    }
}
