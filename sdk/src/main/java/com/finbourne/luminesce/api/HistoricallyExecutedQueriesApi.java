/*
 * FINBOURNE Luminesce Web API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.luminesce.api;

import com.finbourne.luminesce.ApiCallback;
import com.finbourne.luminesce.ApiClient;
import com.finbourne.luminesce.ApiException;
import com.finbourne.luminesce.ApiResponse;
import com.finbourne.luminesce.Configuration;
import com.finbourne.luminesce.Pair;
import com.finbourne.luminesce.ProgressRequestBody;
import com.finbourne.luminesce.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.finbourne.luminesce.model.BackgroundQueryCancelResponse;
import com.finbourne.luminesce.model.BackgroundQueryProgressResponse;
import com.finbourne.luminesce.model.BackgroundQueryResponse;
import com.finbourne.luminesce.model.LusidProblemDetails;
import java.time.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HistoricallyExecutedQueriesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public HistoricallyExecutedQueriesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public HistoricallyExecutedQueriesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call cancelHistoryCall(String executionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}"
            .replace("{" + "executionId" + "}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelHistoryValidateBeforeCall(String executionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling cancelHistory(Async)");
        }

        return cancelHistoryCall(executionId, _callback);

    }


    private ApiResponse<BackgroundQueryCancelResponse> cancelHistoryWithHttpInfo(String executionId) throws ApiException {
        okhttp3.Call localVarCall = cancelHistoryValidateBeforeCall(executionId, null);
        Type localVarReturnType = new TypeToken<BackgroundQueryCancelResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call cancelHistoryAsync(String executionId, final ApiCallback<BackgroundQueryCancelResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = cancelHistoryValidateBeforeCall(executionId, _callback);
        Type localVarReturnType = new TypeToken<BackgroundQueryCancelResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIcancelHistoryRequest {
        private final String executionId;

        private APIcancelHistoryRequest(String executionId) {
            this.executionId = executionId;
        }

        /**
         * Build call for cancelHistory
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return cancelHistoryCall(executionId, _callback);
        }

        /**
         * Execute cancelHistory request
         * @return BackgroundQueryCancelResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public BackgroundQueryCancelResponse execute() throws ApiException {
            ApiResponse<BackgroundQueryCancelResponse> localVarResp = cancelHistoryWithHttpInfo(executionId);
            return localVarResp.getData();
        }

        /**
         * Execute cancelHistory request with HTTP info returned
         * @return ApiResponse&lt;BackgroundQueryCancelResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<BackgroundQueryCancelResponse> executeWithHttpInfo() throws ApiException {
            return cancelHistoryWithHttpInfo(executionId);
        }

        /**
         * Execute cancelHistory request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<BackgroundQueryCancelResponse> _callback) throws ApiException {
            return cancelHistoryAsync(executionId, _callback);
        }
    }

    /**
     * CancelHistory: Cancels (if running) or clears the data from (if completed) a previously started History query
     * Cancel the query (if still running) / clear the data (if already returned) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. 
     * @param executionId ExecutionId returned when starting the query (required)
     * @return APIcancelHistoryRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public APIcancelHistoryRequest cancelHistory(String executionId) {
        return new APIcancelHistoryRequest(executionId);
    }
    private okhttp3.Call fetchHistoryResultHistogramCall(String executionId, String bucketSize, String filter, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}/histogram"
            .replace("{" + "executionId" + "}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (bucketSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bucketSize", bucketSize));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchHistoryResultHistogramValidateBeforeCall(String executionId, String bucketSize, String filter, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling fetchHistoryResultHistogram(Async)");
        }

        return fetchHistoryResultHistogramCall(executionId, bucketSize, filter, jsonProper, _callback);

    }


    private ApiResponse<String> fetchHistoryResultHistogramWithHttpInfo(String executionId, String bucketSize, String filter, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = fetchHistoryResultHistogramValidateBeforeCall(executionId, bucketSize, filter, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call fetchHistoryResultHistogramAsync(String executionId, String bucketSize, String filter, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = fetchHistoryResultHistogramValidateBeforeCall(executionId, bucketSize, filter, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIfetchHistoryResultHistogramRequest {
        private final String executionId;
        private String bucketSize;
        private String filter;
        private Boolean jsonProper;

        private APIfetchHistoryResultHistogramRequest(String executionId) {
            this.executionId = executionId;
        }

        /**
         * Set bucketSize
         * @param bucketSize Optional histogram bucket width. If not provided a set number of buckets between start/end range will be generated. (optional)
         * @return APIfetchHistoryResultHistogramRequest
         */
        public APIfetchHistoryResultHistogramRequest bucketSize(String bucketSize) {
            this.bucketSize = bucketSize;
            return this;
        }

        /**
         * Set filter
         * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
         * @return APIfetchHistoryResultHistogramRequest
         */
        public APIfetchHistoryResultHistogramRequest filter(String filter) {
            this.filter = filter;
            return this;
        }

        /**
         * Set jsonProper
         * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
         * @return APIfetchHistoryResultHistogramRequest
         */
        public APIfetchHistoryResultHistogramRequest jsonProper(Boolean jsonProper) {
            this.jsonProper = jsonProper;
            return this;
        }

        /**
         * Build call for fetchHistoryResultHistogram
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return fetchHistoryResultHistogramCall(executionId, bucketSize, filter, jsonProper, _callback);
        }

        /**
         * Execute fetchHistoryResultHistogram request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = fetchHistoryResultHistogramWithHttpInfo(executionId, bucketSize, filter, jsonProper);
            return localVarResp.getData();
        }

        /**
         * Execute fetchHistoryResultHistogram request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return fetchHistoryResultHistogramWithHttpInfo(executionId, bucketSize, filter, jsonProper);
        }

        /**
         * Execute fetchHistoryResultHistogram request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return fetchHistoryResultHistogramAsync(executionId, bucketSize, filter, jsonProper, _callback);
        }
    }

    /**
     * FetchHistoryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).
     * Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @return APIfetchHistoryResultHistogramRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIfetchHistoryResultHistogramRequest fetchHistoryResultHistogram(String executionId) {
        return new APIfetchHistoryResultHistogramRequest(executionId);
    }
    private okhttp3.Call fetchHistoryResultJsonCall(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}/json"
            .replace("{" + "executionId" + "}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortBy", sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (select != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("select", select));
        }

        if (groupBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupBy", groupBy));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (jsonProper != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonProper", jsonProper));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchHistoryResultJsonValidateBeforeCall(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling fetchHistoryResultJson(Async)");
        }

        return fetchHistoryResultJsonCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, _callback);

    }


    private ApiResponse<String> fetchHistoryResultJsonWithHttpInfo(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper) throws ApiException {
        okhttp3.Call localVarCall = fetchHistoryResultJsonValidateBeforeCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call fetchHistoryResultJsonAsync(String executionId, String sortBy, String filter, String select, String groupBy, Integer limit, Integer page, Boolean jsonProper, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = fetchHistoryResultJsonValidateBeforeCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIfetchHistoryResultJsonRequest {
        private final String executionId;
        private String sortBy;
        private String filter;
        private String select;
        private String groupBy;
        private Integer limit;
        private Integer page;
        private Boolean jsonProper;

        private APIfetchHistoryResultJsonRequest(String executionId) {
            this.executionId = executionId;
        }

        /**
         * Set sortBy
         * @param sortBy Order the results by these fields.   Use the &#x60;-&#x60; sign to denote descending order, e.g. &#x60;-MyFieldName&#x60;. Numeric indexes may be used also, e.g. &#x60;2,-3&#x60;.   Multiple fields can be denoted by a comma e.g. &#x60;-MyFieldName,AnotherFieldName,-AFurtherFieldName&#x60;.   Default is null, the sort order specified in the query itself. (optional)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest sortBy(String sortBy) {
            this.sortBy = sortBy;
            return this;
        }

        /**
         * Set filter
         * @param filter An ODATA filter per Finbourne.Filtering syntax. (optional)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest filter(String filter) {
            this.filter = filter;
            return this;
        }

        /**
         * Set select
         * @param select Default is null (meaning return all columns in the original query itself).  The values are in terms of the result column name from the original data set and are comma delimited.  The power of this comes in that you may aggregate the data if you wish  (that is the main reason for allowing this, in fact).  e.g.:  - &#x60;MyField&#x60;  - &#x60;Max(x) FILTER (WHERE y &gt; 12) as ABC&#x60; (max of a field, if another field lets it qualify, with a nice column name)  - &#x60;count(*)&#x60; (count the rows for the given group, that would produce a rather ugly column name, but it works)  - &#x60;count(distinct x) as numOfXs&#x60;  If there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ].   e.g.  - &#x60;some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name&#x60;   where you would likely want to pass &#x60;1&#x60; as the &#x60;groupBy&#x60; also. (optional)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest select(String select) {
            this.select = select;
            return this;
        }

        /**
         * Set groupBy
         * @param groupBy Groups by the specified fields.   A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).   e.g. &#x60;2,3&#x60;, &#x60;myColumn&#x60;.   Default is null (meaning no grouping will be performed on the selected columns).   This applies only over the result set being requested here, meaning indexes into the \&quot;select\&quot; parameter fields.   Only specify this if you are selecting aggregations in the \&quot;select\&quot; parameter. (optional)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest groupBy(String groupBy) {
            this.groupBy = groupBy;
            return this;
        }

        /**
         * Set limit
         * @param limit When paginating, only return this number of records, page should also be specified. (optional, default to 0)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest limit(Integer limit) {
            this.limit = limit;
            return this;
        }

        /**
         * Set page
         * @param page 0-N based on chunk sized determined by the limit, ignored if limit &lt; 1. (optional, default to 0)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest page(Integer page) {
            this.page = page;
            return this;
        }

        /**
         * Set jsonProper
         * @param jsonProper Should this be text/json (not json-encoded-as-a-string) (optional, default to false)
         * @return APIfetchHistoryResultJsonRequest
         */
        public APIfetchHistoryResultJsonRequest jsonProper(Boolean jsonProper) {
            this.jsonProper = jsonProper;
            return this;
        }

        /**
         * Build call for fetchHistoryResultJson
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return fetchHistoryResultJsonCall(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, _callback);
        }

        /**
         * Execute fetchHistoryResultJson request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ApiResponse<String> localVarResp = fetchHistoryResultJsonWithHttpInfo(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper);
            return localVarResp.getData();
        }

        /**
         * Execute fetchHistoryResultJson request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            return fetchHistoryResultJsonWithHttpInfo(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper);
        }

        /**
         * Execute fetchHistoryResultJson request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            return fetchHistoryResultJsonAsync(executionId, sortBy, filter, select, groupBy, limit, page, jsonProper, _callback);
        }
    }

    /**
     * FetchHistoryResultJson: Fetches the result from a previously started query, in JSON format.
     * Fetch the data in Json format (if available, or if not simply being informed it is not yet ready) The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t (yet) exist. - 429 Too Many Requests : Please try your request again soon  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @return APIfetchHistoryResultJsonRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public APIfetchHistoryResultJsonRequest fetchHistoryResultJson(String executionId) {
        return new APIfetchHistoryResultJsonRequest(executionId);
    }
    private okhttp3.Call getHistoryCall(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (endAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endAt", endAt));
        }

        if (freeTextSearch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("freeTextSearch", freeTextSearch));
        }

        if (showAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("showAll", showAll));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHistoryValidateBeforeCall(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll, final ApiCallback _callback) throws ApiException {
        return getHistoryCall(startAt, endAt, freeTextSearch, showAll, _callback);

    }


    private ApiResponse<BackgroundQueryResponse> getHistoryWithHttpInfo(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll) throws ApiException {
        okhttp3.Call localVarCall = getHistoryValidateBeforeCall(startAt, endAt, freeTextSearch, showAll, null);
        Type localVarReturnType = new TypeToken<BackgroundQueryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getHistoryAsync(OffsetDateTime startAt, OffsetDateTime endAt, String freeTextSearch, Boolean showAll, final ApiCallback<BackgroundQueryResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getHistoryValidateBeforeCall(startAt, endAt, freeTextSearch, showAll, _callback);
        Type localVarReturnType = new TypeToken<BackgroundQueryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetHistoryRequest {
        private OffsetDateTime startAt;
        private OffsetDateTime endAt;
        private String freeTextSearch;
        private Boolean showAll;

        private APIgetHistoryRequest() {
        }

        /**
         * Set startAt
         * @param startAt Date time to start the search from. Will default to Now - 1 Day (optional)
         * @return APIgetHistoryRequest
         */
        public APIgetHistoryRequest startAt(OffsetDateTime startAt) {
            this.startAt = startAt;
            return this;
        }

        /**
         * Set endAt
         * @param endAt Date time to end the search at. Defaults to now. (optional)
         * @return APIgetHistoryRequest
         */
        public APIgetHistoryRequest endAt(OffsetDateTime endAt) {
            this.endAt = endAt;
            return this;
        }

        /**
         * Set freeTextSearch
         * @param freeTextSearch Some test that must be in at least one field returned. (optional)
         * @return APIgetHistoryRequest
         */
        public APIgetHistoryRequest freeTextSearch(String freeTextSearch) {
            this.freeTextSearch = freeTextSearch;
            return this;
        }

        /**
         * Set showAll
         * @param showAll For users with extra permissions, they may optionally see other users&#39; queries. (optional, default to false)
         * @return APIgetHistoryRequest
         */
        public APIgetHistoryRequest showAll(Boolean showAll) {
            this.showAll = showAll;
            return this;
        }

        /**
         * Build call for getHistory
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Accepted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getHistoryCall(startAt, endAt, freeTextSearch, showAll, _callback);
        }

        /**
         * Execute getHistory request
         * @return BackgroundQueryResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Accepted </td><td>  -  </td></tr>
         </table>
         */
        public BackgroundQueryResponse execute() throws ApiException {
            ApiResponse<BackgroundQueryResponse> localVarResp = getHistoryWithHttpInfo(startAt, endAt, freeTextSearch, showAll);
            return localVarResp.getData();
        }

        /**
         * Execute getHistory request with HTTP info returned
         * @return ApiResponse&lt;BackgroundQueryResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Accepted </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<BackgroundQueryResponse> executeWithHttpInfo() throws ApiException {
            return getHistoryWithHttpInfo(startAt, endAt, freeTextSearch, showAll);
        }

        /**
         * Execute getHistory request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Accepted </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<BackgroundQueryResponse> _callback) throws ApiException {
            return getHistoryAsync(startAt, endAt, freeTextSearch, showAll, _callback);
        }
    }

    /**
     * GetHistory: Shows queries executed in a given historical time window (in Json format).
     *  Starts to load the historical query logs for a certain time range, search criteria, etc.  The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized 
     * @return APIgetHistoryRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Accepted </td><td>  -  </td></tr>
     </table>
     */
    public APIgetHistoryRequest getHistory() {
        return new APIgetHistoryRequest();
    }
    private okhttp3.Call getProgressOfHistoryCall(String executionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/History/{executionId}"
            .replace("{" + "executionId" + "}", localVarApiClient.escapeString(executionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getProgressOfHistoryValidateBeforeCall(String executionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'executionId' is set
        if (executionId == null) {
            throw new ApiException("Missing the required parameter 'executionId' when calling getProgressOfHistory(Async)");
        }

        return getProgressOfHistoryCall(executionId, _callback);

    }


    private ApiResponse<BackgroundQueryProgressResponse> getProgressOfHistoryWithHttpInfo(String executionId) throws ApiException {
        okhttp3.Call localVarCall = getProgressOfHistoryValidateBeforeCall(executionId, null);
        Type localVarReturnType = new TypeToken<BackgroundQueryProgressResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getProgressOfHistoryAsync(String executionId, final ApiCallback<BackgroundQueryProgressResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getProgressOfHistoryValidateBeforeCall(executionId, _callback);
        Type localVarReturnType = new TypeToken<BackgroundQueryProgressResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class APIgetProgressOfHistoryRequest {
        private final String executionId;

        private APIgetProgressOfHistoryRequest(String executionId) {
            this.executionId = executionId;
        }

        /**
         * Build call for getProgressOfHistory
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getProgressOfHistoryCall(executionId, _callback);
        }

        /**
         * Execute getProgressOfHistory request
         * @return BackgroundQueryProgressResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public BackgroundQueryProgressResponse execute() throws ApiException {
            ApiResponse<BackgroundQueryProgressResponse> localVarResp = getProgressOfHistoryWithHttpInfo(executionId);
            return localVarResp.getData();
        }

        /**
         * Execute getProgressOfHistory request with HTTP info returned
         * @return ApiResponse&lt;BackgroundQueryProgressResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<BackgroundQueryProgressResponse> executeWithHttpInfo() throws ApiException {
            return getProgressOfHistoryWithHttpInfo(executionId);
        }

        /**
         * Execute getProgressOfHistory request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<BackgroundQueryProgressResponse> _callback) throws ApiException {
            return getProgressOfHistoryAsync(executionId, _callback);
        }
    }

    /**
     * GetProgressOfHistory: View progress information (up until this point) of a history query
     * View progress information (up until this point) of previously started History query The following error codes are to be anticipated with standard Problem Detail reports: - 401 Unauthorized - 404 Not Found : The requested query result doesn&#39;t exist and is not running. - 429 Too Many Requests : Please try your request again soon  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn&#39;t yet have this data available.  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.
     * @param executionId ExecutionId returned when starting the query (required)
     * @return APIgetProgressOfHistoryRequest
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public APIgetProgressOfHistoryRequest getProgressOfHistory(String executionId) {
        return new APIgetProgressOfHistoryRequest(executionId);
    }
}
