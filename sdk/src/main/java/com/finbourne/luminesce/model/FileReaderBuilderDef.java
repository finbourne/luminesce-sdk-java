/*
 * FINBOURNE Luminesce Web API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.luminesce.model;

import java.util.Objects;
import com.finbourne.luminesce.model.AutoDetectType;
import com.finbourne.luminesce.model.ColumnInfo;
import com.finbourne.luminesce.model.OptionsCsv;
import com.finbourne.luminesce.model.OptionsExcel;
import com.finbourne.luminesce.model.OptionsParquet;
import com.finbourne.luminesce.model.OptionsSqLite;
import com.finbourne.luminesce.model.OptionsXml;
import com.finbourne.luminesce.model.Source;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.luminesce.JSON;

/**
 * Information on how to construct a file-read sql query
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FileReaderBuilderDef {
  public static final String SERIALIZED_NAME_AUTO_DETECT = "autoDetect";
  @SerializedName(SERIALIZED_NAME_AUTO_DETECT)
  private AutoDetectType autoDetect;

  public static final String SERIALIZED_NAME_COLUMNS = "columns";
  @SerializedName(SERIALIZED_NAME_COLUMNS)
  private List<ColumnInfo> columns;

  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private Integer limit;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private Source source;

  public static final String SERIALIZED_NAME_AVAILABLE_SOURCES = "availableSources";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_SOURCES)
  private List<Source> availableSources;

  public static final String SERIALIZED_NAME_VARIABLE_NAME = "variableName";
  @SerializedName(SERIALIZED_NAME_VARIABLE_NAME)
  private String variableName;

  public static final String SERIALIZED_NAME_FILE_PATH = "filePath";
  @SerializedName(SERIALIZED_NAME_FILE_PATH)
  private String filePath;

  public static final String SERIALIZED_NAME_FOLDER_FILTER = "folderFilter";
  @SerializedName(SERIALIZED_NAME_FOLDER_FILTER)
  private String folderFilter;

  public static final String SERIALIZED_NAME_ZIP_FILTER = "zipFilter";
  @SerializedName(SERIALIZED_NAME_ZIP_FILTER)
  private String zipFilter;

  public static final String SERIALIZED_NAME_ADD_FILE_NAME = "addFileName";
  @SerializedName(SERIALIZED_NAME_ADD_FILE_NAME)
  private Boolean addFileName;

  public static final String SERIALIZED_NAME_CSV = "csv";
  @SerializedName(SERIALIZED_NAME_CSV)
  private OptionsCsv csv;

  public static final String SERIALIZED_NAME_EXCEL = "excel";
  @SerializedName(SERIALIZED_NAME_EXCEL)
  private OptionsExcel excel;

  public static final String SERIALIZED_NAME_SQ_LITE = "sqLite";
  @SerializedName(SERIALIZED_NAME_SQ_LITE)
  private OptionsSqLite sqLite;

  public static final String SERIALIZED_NAME_XML = "xml";
  @SerializedName(SERIALIZED_NAME_XML)
  private OptionsXml xml;

  public static final String SERIALIZED_NAME_PARQUET = "parquet";
  @SerializedName(SERIALIZED_NAME_PARQUET)
  private OptionsParquet parquet;

  public FileReaderBuilderDef() {
  }

  public FileReaderBuilderDef autoDetect(AutoDetectType autoDetect) {
    
    this.autoDetect = autoDetect;
    return this;
  }

   /**
   * Get autoDetect
   * @return autoDetect
  **/
  @jakarta.annotation.Nullable
  public AutoDetectType getAutoDetect() {
    return autoDetect;
  }


  public void setAutoDetect(AutoDetectType autoDetect) {
    this.autoDetect = autoDetect;
  }


  public FileReaderBuilderDef columns(List<ColumnInfo> columns) {
    
    this.columns = columns;
    return this;
  }

  public FileReaderBuilderDef addColumnsItem(ColumnInfo columnsItem) {
    if (this.columns == null) {
      this.columns = new ArrayList<>();
    }
    this.columns.add(columnsItem);
    return this;
  }

   /**
   * Column information for the results
   * @return columns
  **/
  @jakarta.annotation.Nullable
  public List<ColumnInfo> getColumns() {
    return columns;
  }


  public void setColumns(List<ColumnInfo> columns) {
    this.columns = columns;
  }


  public FileReaderBuilderDef limit(Integer limit) {
    
    this.limit = limit;
    return this;
  }

   /**
   * What limit be added to the load query? Less than or equal to zero means none
   * @return limit
  **/
  @jakarta.annotation.Nullable
  public Integer getLimit() {
    return limit;
  }


  public void setLimit(Integer limit) {
    this.limit = limit;
  }


  public FileReaderBuilderDef source(Source source) {
    
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @jakarta.annotation.Nullable
  public Source getSource() {
    return source;
  }


  public void setSource(Source source) {
    this.source = source;
  }


  public FileReaderBuilderDef availableSources(List<Source> availableSources) {
    
    this.availableSources = availableSources;
    return this;
  }

  public FileReaderBuilderDef addAvailableSourcesItem(Source availableSourcesItem) {
    if (this.availableSources == null) {
      this.availableSources = new ArrayList<>();
    }
    this.availableSources.add(availableSourcesItem);
    return this;
  }

   /**
   * The source locations the user has access to. The provider in essence.
   * @return availableSources
  **/
  @jakarta.annotation.Nullable
  public List<Source> getAvailableSources() {
    return availableSources;
  }


  public void setAvailableSources(List<Source> availableSources) {
    this.availableSources = availableSources;
  }


  public FileReaderBuilderDef variableName(String variableName) {
    
    this.variableName = variableName;
    return this;
  }

   /**
   * The name of the variable for the &#x60;use&#x60; statement
   * @return variableName
  **/
  @jakarta.annotation.Nullable
  public String getVariableName() {
    return variableName;
  }


  public void setVariableName(String variableName) {
    this.variableName = variableName;
  }


  public FileReaderBuilderDef filePath(String filePath) {
    
    this.filePath = filePath;
    return this;
  }

   /**
   * The file (or folder) path
   * @return filePath
  **/
  @jakarta.annotation.Nullable
  public String getFilePath() {
    return filePath;
  }


  public void setFilePath(String filePath) {
    this.filePath = filePath;
  }


  public FileReaderBuilderDef folderFilter(String folderFilter) {
    
    this.folderFilter = folderFilter;
    return this;
  }

   /**
   * The filter to apply to a folder (all matching files then being read) a RegExp
   * @return folderFilter
  **/
  @jakarta.annotation.Nullable
  public String getFolderFilter() {
    return folderFilter;
  }


  public void setFolderFilter(String folderFilter) {
    this.folderFilter = folderFilter;
  }


  public FileReaderBuilderDef zipFilter(String zipFilter) {
    
    this.zipFilter = zipFilter;
    return this;
  }

   /**
   * The filter to apply to folder structures with zip archives (all matching files then being read) a RegExp
   * @return zipFilter
  **/
  @jakarta.annotation.Nullable
  public String getZipFilter() {
    return zipFilter;
  }


  public void setZipFilter(String zipFilter) {
    this.zipFilter = zipFilter;
  }


  public FileReaderBuilderDef addFileName(Boolean addFileName) {
    
    this.addFileName = addFileName;
    return this;
  }

   /**
   * Should a file name column be added to the output?
   * @return addFileName
  **/
  @jakarta.annotation.Nullable
  public Boolean getAddFileName() {
    return addFileName;
  }


  public void setAddFileName(Boolean addFileName) {
    this.addFileName = addFileName;
  }


  public FileReaderBuilderDef csv(OptionsCsv csv) {
    
    this.csv = csv;
    return this;
  }

   /**
   * Get csv
   * @return csv
  **/
  @jakarta.annotation.Nullable
  public OptionsCsv getCsv() {
    return csv;
  }


  public void setCsv(OptionsCsv csv) {
    this.csv = csv;
  }


  public FileReaderBuilderDef excel(OptionsExcel excel) {
    
    this.excel = excel;
    return this;
  }

   /**
   * Get excel
   * @return excel
  **/
  @jakarta.annotation.Nullable
  public OptionsExcel getExcel() {
    return excel;
  }


  public void setExcel(OptionsExcel excel) {
    this.excel = excel;
  }


  public FileReaderBuilderDef sqLite(OptionsSqLite sqLite) {
    
    this.sqLite = sqLite;
    return this;
  }

   /**
   * Get sqLite
   * @return sqLite
  **/
  @jakarta.annotation.Nullable
  public OptionsSqLite getSqLite() {
    return sqLite;
  }


  public void setSqLite(OptionsSqLite sqLite) {
    this.sqLite = sqLite;
  }


  public FileReaderBuilderDef xml(OptionsXml xml) {
    
    this.xml = xml;
    return this;
  }

   /**
   * Get xml
   * @return xml
  **/
  @jakarta.annotation.Nullable
  public OptionsXml getXml() {
    return xml;
  }


  public void setXml(OptionsXml xml) {
    this.xml = xml;
  }


  public FileReaderBuilderDef parquet(OptionsParquet parquet) {
    
    this.parquet = parquet;
    return this;
  }

   /**
   * Get parquet
   * @return parquet
  **/
  @jakarta.annotation.Nullable
  public OptionsParquet getParquet() {
    return parquet;
  }


  public void setParquet(OptionsParquet parquet) {
    this.parquet = parquet;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FileReaderBuilderDef fileReaderBuilderDef = (FileReaderBuilderDef) o;
    return Objects.equals(this.autoDetect, fileReaderBuilderDef.autoDetect) &&
        Objects.equals(this.columns, fileReaderBuilderDef.columns) &&
        Objects.equals(this.limit, fileReaderBuilderDef.limit) &&
        Objects.equals(this.source, fileReaderBuilderDef.source) &&
        Objects.equals(this.availableSources, fileReaderBuilderDef.availableSources) &&
        Objects.equals(this.variableName, fileReaderBuilderDef.variableName) &&
        Objects.equals(this.filePath, fileReaderBuilderDef.filePath) &&
        Objects.equals(this.folderFilter, fileReaderBuilderDef.folderFilter) &&
        Objects.equals(this.zipFilter, fileReaderBuilderDef.zipFilter) &&
        Objects.equals(this.addFileName, fileReaderBuilderDef.addFileName) &&
        Objects.equals(this.csv, fileReaderBuilderDef.csv) &&
        Objects.equals(this.excel, fileReaderBuilderDef.excel) &&
        Objects.equals(this.sqLite, fileReaderBuilderDef.sqLite) &&
        Objects.equals(this.xml, fileReaderBuilderDef.xml) &&
        Objects.equals(this.parquet, fileReaderBuilderDef.parquet);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoDetect, columns, limit, source, availableSources, variableName, filePath, folderFilter, zipFilter, addFileName, csv, excel, sqLite, xml, parquet);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FileReaderBuilderDef {\n");
    sb.append("    autoDetect: ").append(toIndentedString(autoDetect)).append("\n");
    sb.append("    columns: ").append(toIndentedString(columns)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    availableSources: ").append(toIndentedString(availableSources)).append("\n");
    sb.append("    variableName: ").append(toIndentedString(variableName)).append("\n");
    sb.append("    filePath: ").append(toIndentedString(filePath)).append("\n");
    sb.append("    folderFilter: ").append(toIndentedString(folderFilter)).append("\n");
    sb.append("    zipFilter: ").append(toIndentedString(zipFilter)).append("\n");
    sb.append("    addFileName: ").append(toIndentedString(addFileName)).append("\n");
    sb.append("    csv: ").append(toIndentedString(csv)).append("\n");
    sb.append("    excel: ").append(toIndentedString(excel)).append("\n");
    sb.append("    sqLite: ").append(toIndentedString(sqLite)).append("\n");
    sb.append("    xml: ").append(toIndentedString(xml)).append("\n");
    sb.append("    parquet: ").append(toIndentedString(parquet)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoDetect");
    openapiFields.add("columns");
    openapiFields.add("limit");
    openapiFields.add("source");
    openapiFields.add("availableSources");
    openapiFields.add("variableName");
    openapiFields.add("filePath");
    openapiFields.add("folderFilter");
    openapiFields.add("zipFilter");
    openapiFields.add("addFileName");
    openapiFields.add("csv");
    openapiFields.add("excel");
    openapiFields.add("sqLite");
    openapiFields.add("xml");
    openapiFields.add("parquet");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FileReaderBuilderDef
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FileReaderBuilderDef.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FileReaderBuilderDef is not found in the empty JSON string", FileReaderBuilderDef.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("columns") != null && !jsonObj.get("columns").isJsonNull()) {
        JsonArray jsonArraycolumns = jsonObj.getAsJsonArray("columns");
        if (jsonArraycolumns != null) {
          // ensure the json data is an array
          if (!jsonObj.get("columns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `columns` to be an array in the JSON string but got `%s`", jsonObj.get("columns").toString()));
          }

          // validate the optional field `columns` (array)
          for (int i = 0; i < jsonArraycolumns.size(); i++) {
            ColumnInfo.validateJsonElement(jsonArraycolumns.get(i));
          };
        }
      }
      // validate the optional field `source`
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) {
        Source.validateJsonElement(jsonObj.get("source"));
      }
      if (jsonObj.get("availableSources") != null && !jsonObj.get("availableSources").isJsonNull()) {
        JsonArray jsonArrayavailableSources = jsonObj.getAsJsonArray("availableSources");
        if (jsonArrayavailableSources != null) {
          // ensure the json data is an array
          if (!jsonObj.get("availableSources").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `availableSources` to be an array in the JSON string but got `%s`", jsonObj.get("availableSources").toString()));
          }

          // validate the optional field `availableSources` (array)
          for (int i = 0; i < jsonArrayavailableSources.size(); i++) {
            Source.validateJsonElement(jsonArrayavailableSources.get(i));
          };
        }
      }
      if ((jsonObj.get("variableName") != null && !jsonObj.get("variableName").isJsonNull()) && !jsonObj.get("variableName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `variableName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("variableName").toString()));
      }
      if ((jsonObj.get("filePath") != null && !jsonObj.get("filePath").isJsonNull()) && !jsonObj.get("filePath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filePath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filePath").toString()));
      }
      if ((jsonObj.get("folderFilter") != null && !jsonObj.get("folderFilter").isJsonNull()) && !jsonObj.get("folderFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `folderFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("folderFilter").toString()));
      }
      if ((jsonObj.get("zipFilter") != null && !jsonObj.get("zipFilter").isJsonNull()) && !jsonObj.get("zipFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zipFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zipFilter").toString()));
      }
      // validate the optional field `csv`
      if (jsonObj.get("csv") != null && !jsonObj.get("csv").isJsonNull()) {
        OptionsCsv.validateJsonElement(jsonObj.get("csv"));
      }
      // validate the optional field `excel`
      if (jsonObj.get("excel") != null && !jsonObj.get("excel").isJsonNull()) {
        OptionsExcel.validateJsonElement(jsonObj.get("excel"));
      }
      // validate the optional field `sqLite`
      if (jsonObj.get("sqLite") != null && !jsonObj.get("sqLite").isJsonNull()) {
        OptionsSqLite.validateJsonElement(jsonObj.get("sqLite"));
      }
      // validate the optional field `xml`
      if (jsonObj.get("xml") != null && !jsonObj.get("xml").isJsonNull()) {
        OptionsXml.validateJsonElement(jsonObj.get("xml"));
      }
      // validate the optional field `parquet`
      if (jsonObj.get("parquet") != null && !jsonObj.get("parquet").isJsonNull()) {
        OptionsParquet.validateJsonElement(jsonObj.get("parquet"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FileReaderBuilderDef.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FileReaderBuilderDef' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FileReaderBuilderDef> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FileReaderBuilderDef.class));

       return (TypeAdapter<T>) new TypeAdapter<FileReaderBuilderDef>() {
           @Override
           public void write(JsonWriter out, FileReaderBuilderDef value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FileReaderBuilderDef read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FileReaderBuilderDef given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FileReaderBuilderDef
  * @throws IOException if the JSON string is invalid with respect to FileReaderBuilderDef
  */
  public static FileReaderBuilderDef fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FileReaderBuilderDef.class);
  }

 /**
  * Convert an instance of FileReaderBuilderDef to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
